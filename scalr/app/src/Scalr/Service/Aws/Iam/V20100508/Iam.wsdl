<?xml version="1.0"?>
<wsdl:definitions
  targetNamespace="https://iam.amazonaws.com/doc/2010-05-08/"
  xmlns:tns="https://iam.amazonaws.com/doc/2010-05-08/"
  xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/"
  xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
  xmlns:wsa="http://www.w3.org/2005/08/addressing/"
  xmlns:xs="http://www.w3.org/2001/XMLSchema">

  <wsdl:types>

    <xs:schema
      targetNamespace="https://iam.amazonaws.com/doc/2010-05-08/"
      elementFormDefault="qualified">

      <xs:element name="ResponseMetadata">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="RequestId" type="xs:string"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="Error">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="Type">
              <xs:simpleType>
                <xs:restriction base="xs:string">
                  <xs:enumeration value="Receiver"/>
                  <xs:enumeration value="Sender"/>
                </xs:restriction>
              </xs:simpleType>
            </xs:element>
            <xs:element name="Code" type="xs:string"/>
            <xs:element name="Message" type="xs:string"/>
            <xs:element name="Detail">
              <xs:complexType>
                <xs:sequence>
                  <xs:any maxOccurs="unbounded" minOccurs="0" namespace="##any" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute namespace="##other" processContents="lax"/>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ErrorResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:Error" maxOccurs="unbounded"/>
            <xs:element name="RequestId" type="xs:string"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="DeleteAccountAlias">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="AccountAlias" type="tns:accountAliasType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the account alias to delete.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="DeleteAccountAliasResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListGroups">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="PathPrefix" type="tns:pathPrefixType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The path prefix for filtering the results. For example: <code>/division_abc/subdivision_xyz/</code>, which
                  would get all groups whose path starts with <code>/division_abc/subdivision_xyz/</code>.</p>
              
                  <p>This parameter is optional. If it is not included, it defaults to a slash (/), listing all groups.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Marker" type="tns:markerType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Use this only when paginating results, and only in a subsequent request after you've received a response where
                  the results are truncated. Set it to the value of the <code>Marker</code> element in the response you just received.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="MaxItems" type="tns:maxItemsType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Use this only when paginating results to indicate the maximum number of groups you want in the response.
                  If there are additional groups beyond the maximum you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListGroupsResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ListGroupsResult"/>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListGroupsResult">
        <xs:complexType>

            <xs:annotation>
              <xs:documentation><![CDATA[
                <p>Contains the result of a successful invocation of the <a>ListGroups</a> action.</p>
              ]]></xs:documentation>
            </xs:annotation>
            
          <xs:sequence>
            <xs:element name="Groups" type="tns:groupListType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>A list of groups.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="IsTruncated" type="xs:boolean" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>A flag that indicates whether there are more groups to list. If your results were truncated,
                  you can make a subsequent pagination request using the <code>Marker</code> request parameter to retrieve more
                  groups in the list.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Marker" type="tns:markerType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>If <code>IsTruncated</code> is <code>true</code>, this element is present and contains the value to use 
                  for the <code>Marker</code> parameter in a subsequent pagination request.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="DeleteAccessKey">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="UserName" type="tns:existingUserNameType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the user whose key you want to delete.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="AccessKeyId" type="tns:accessKeyIdType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The Access Key ID for the Access Key ID and Secret Access Key you want to delete.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="DeleteAccessKeyResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="DeleteVirtualMFADevice">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="SerialNumber" type="tns:serialNumberType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The serial number that uniquely identifies the MFA device. For virtual MFA devices, the serial number is the same as the ARN.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="DeleteVirtualMFADeviceResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="DeleteUserPolicy">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="UserName" type="tns:existingUserNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the user the policy is associated with.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="PolicyName" type="tns:policyNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the policy document to delete.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="DeleteUserPolicyResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="PutUserPolicy">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="UserName" type="tns:existingUserNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the user to associate the policy with.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="PolicyName" type="tns:policyNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the policy document.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="PolicyDocument" type="tns:policyDocumentType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The policy document.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="PutUserPolicyResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListServerCertificates">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="PathPrefix" type="tns:pathPrefixType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The path prefix for filtering the results. For example: <code>/company/servercerts</code> would get all server
              	certificates for which the path starts with <code>/company/servercerts</code>.</p>
              
                  <p>This parameter is optional. If it is not included, it defaults to a slash (/), listing all server certificates.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Marker" type="tns:markerType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Use this only when paginating results, and only in a subsequent request after you've received a response where
                  the results are truncated. Set it to the value of the <code>Marker</code> element in the response you just received.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="MaxItems" type="tns:maxItemsType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Use this only when paginating results to indicate the maximum number of server certificates you want in the response. If
                  there are additional server certificates beyond the maximum you specify, the <code>IsTruncated</code> response element will
                  be set to <code>true</code>.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListServerCertificatesResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ListServerCertificatesResult"/>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListServerCertificatesResult">
        <xs:complexType>

            <xs:annotation>
              <xs:documentation><![CDATA[
                <p>Contains the result of a successful invocation of the <a>ListServerCertificates</a> action.</p>
              ]]></xs:documentation>
            </xs:annotation>
            
          <xs:sequence>
            <xs:element name="ServerCertificateMetadataList" type="tns:serverCertificateMetadataListType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>A list of server certificates.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="IsTruncated" type="xs:boolean" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>A flag that indicates whether there are more server certificates to list. If your results were truncated, you can make a
                  subsequent pagination request using the <code>Marker</code> request parameter to retrieve more server certificates in the list.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Marker" type="tns:markerType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>If <code>IsTruncated</code> is <code>true</code>, this element is present and contains the value to use for
                  the <code>Marker</code> parameter in a subsequent pagination request.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="GetUserPolicy">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="UserName" type="tns:existingUserNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the user who the policy is associated with.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="PolicyName" type="tns:policyNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the policy document to get.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="GetUserPolicyResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:GetUserPolicyResult"/>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="GetUserPolicyResult">
        <xs:complexType>

            <xs:annotation>
              <xs:documentation><![CDATA[
                <p>Contains the result of a successful invocation of the <a>GetUserPolicy</a> action.</p>
              ]]></xs:documentation>
            </xs:annotation>
            
          <xs:sequence>
            <xs:element name="UserName" type="tns:existingUserNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The user the policy is associated with.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="PolicyName" type="tns:policyNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The name of the policy.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="PolicyDocument" type="tns:policyDocumentType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The policy document.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="UpdateServerCertificate">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="ServerCertificateName" type="tns:serverCertificateNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The name of the server certificate that you want to update.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="NewPath" type="tns:pathType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The new path for the server certificate. Include this only if you are updating the server certificate's path.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="NewServerCertificateName" type="tns:serverCertificateNameType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The new name for the server certificate. Include this only if you are updating the server certificate's name.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="UpdateServerCertificateResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="UpdateUser">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="UserName" type="tns:existingUserNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the user to update.  If you're changing the name of the user, this is the original user name.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="NewPath" type="tns:pathType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>New path for the user. Include this parameter only if you're changing the user's path.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="NewUserName" type="tns:userNameType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>New name for the user. Include this parameter only if you're changing the user's name.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="UpdateUserResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="PutRolePolicy">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="RoleName" type="tns:roleNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the role to associate the policy with.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="PolicyName" type="tns:policyNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the policy document.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="PolicyDocument" type="tns:policyDocumentType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The policy document.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="PutRolePolicyResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="UpdateSigningCertificate">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="UserName" type="tns:existingUserNameType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the user the signing certificate belongs to.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="CertificateId" type="tns:certificateIdType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The ID of the signing certificate you want to update.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Status" type="tns:statusType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The status you want to assign to the certificate. <code>Active</code> means the certificate can be
                   used for API calls to AWS, while <code>Inactive</code> means the certificate cannot be used.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="UpdateSigningCertificateResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="DeleteGroupPolicy">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="GroupName" type="tns:groupNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the group the policy is associated with.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="PolicyName" type="tns:policyNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the policy document to delete.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="DeleteGroupPolicyResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListUsers">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="PathPrefix" type="tns:pathPrefixType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The path prefix for filtering the results. For example: <code>/division_abc/subdivision_xyz/</code>, which
                  would get all user names whose path starts with <code>/division_abc/subdivision_xyz/</code>.</p>
              
                  <p>This parameter is optional. If it is not included, it defaults to a slash (/), listing all user names.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Marker" type="tns:markerType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Use this parameter only when paginating results, and only in a subsequent request after you've received a response where
                  the results are truncated. Set it to the value of the <code>Marker</code> element in the response you just received.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="MaxItems" type="tns:maxItemsType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Use this parameter only when paginating results to indicate the maximum number of user names you want in the response. If
                  there are additional user names beyond the maximum you specify, the <code>IsTruncated</code> response element 
                    is <code>true</code>.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListUsersResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ListUsersResult"/>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListUsersResult">
        <xs:complexType>

            <xs:annotation>
              <xs:documentation><![CDATA[
                <p>Contains the result of a successful invocation of the <a>ListUsers</a> action.</p>
              ]]></xs:documentation>
            </xs:annotation>
            
          <xs:sequence>
            <xs:element name="Users" type="tns:userListType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>A list of users.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="IsTruncated" type="xs:boolean" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>A flag that indicates whether there are more user names to list. If your results were truncated, you can make a
                  subsequent pagination request using the <code>Marker</code> request parameter to retrieve more users in the list.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Marker" type="tns:markerType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>If <code>IsTruncated</code> is <code>true</code>, this element is present and contains the value to use for
                  the <code>Marker</code> parameter in a subsequent pagination request.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="UpdateGroup">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="GroupName" type="tns:groupNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the group to update. If you're changing the name of the group, this is the original name.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="NewPath" type="tns:pathType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>New path for the group. Only include this if changing the group's path.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="NewGroupName" type="tns:groupNameType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>New name for the group. Only include this if changing the group's name.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="UpdateGroupResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="CreateUser">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="Path" type="tns:pathType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The path for the user name. For more information about paths, see <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?Using_Identifiers.html" target="_blank">Identifiers for IAM Entities</a> in <i>Using AWS Identity and Access Management</i>.</p>
              
                  <p>This parameter is optional. If it is not included, it defaults to a slash (/).</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="UserName" type="tns:userNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the user to create.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="CreateUserResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:CreateUserResult"/>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="CreateUserResult">
        <xs:complexType>

            <xs:annotation>
              <xs:documentation><![CDATA[
                <p>Contains the result of a successful invocation of the <a>CreateUser</a> action.</p>
              ]]></xs:documentation>
            </xs:annotation>
            
          <xs:sequence>
            <xs:element name="User" type="tns:User" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Information about the user.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="EnableMFADevice">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="UserName" type="tns:existingUserNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the user for whom you want to enable the MFA device.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="SerialNumber" type="tns:serialNumberType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The serial number that uniquely identifies the MFA device. For virtual MFA devices, the 
                    serial number is the device ARN.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="AuthenticationCode1" type="tns:authenticationCodeType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>An authentication code emitted by the device.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="AuthenticationCode2" type="tns:authenticationCodeType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>A subsequent authentication code emitted by the device.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="EnableMFADeviceResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="DeleteAccountPasswordPolicy">
        <xs:complexType>
          <xs:sequence>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="DeleteAccountPasswordPolicyResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="GetLoginProfile">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="UserName" type="tns:userNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the user whose login profile you want to retrieve.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="GetLoginProfileResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:GetLoginProfileResult"/>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="GetLoginProfileResult">
        <xs:complexType>

            <xs:annotation>
              <xs:documentation><![CDATA[
                <p>Contains the result of a successful invocation of the <a>GetLoginProfile</a> action.</p>
              ]]></xs:documentation>
            </xs:annotation>
            
          <xs:sequence>
            <xs:element name="LoginProfile" type="tns:LoginProfile">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>User name and password create date for the user.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="UploadServerCertificate">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="Path" type="tns:pathType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The path for the server certificate. For more information about paths, see 
              	<a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?Using_Identifiers.html" target="_blank">Identifiers for IAM Entities</a> in <i>Using AWS Identity and Access Management</i>.</p>
              
                  <p>This parameter is optional. If it is not included, it defaults to a slash (/).</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="ServerCertificateName" type="tns:serverCertificateNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The name for the server certificate. Do not include the path in this value.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="CertificateBody" type="tns:certificateBodyType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The contents of the public key certificate in PEM-encoded format.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="PrivateKey" type="tns:privateKeyType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The contents of the private key in PEM-encoded format.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="CertificateChain" type="tns:certificateChainType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The contents of the certificate chain. This is typically a concatenation of the PEM-encoded public key certificates of the chain.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="UploadServerCertificateResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:UploadServerCertificateResult"/>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="UploadServerCertificateResult">
        <xs:complexType>

            <xs:annotation>
              <xs:documentation><![CDATA[
                <p>Contains the result of a successful invocation of the <a>UploadServerCertificate</a> action.</p>
              ]]></xs:documentation>
            </xs:annotation>
            
          <xs:sequence>
            <xs:element name="ServerCertificateMetadata" type="tns:ServerCertificateMetadata" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The meta information of the uploaded server certificate without its certificate body, certificate chain, and private key.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="CreateGroup">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="Path" type="tns:pathType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The path to the group. For more information about paths, see <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?Using_Identifiers.html" target="_blank">Identifiers for IAM Entities</a> in <i>Using AWS Identity and Access Management</i>.</p>
              
                  <p>This parameter is optional. If it is not included, it defaults to a slash (/).</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="GroupName" type="tns:groupNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the group to create. Do not include the path in this value.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="CreateGroupResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:CreateGroupResult"/>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="CreateGroupResult">
        <xs:complexType>

            <xs:annotation>
              <xs:documentation><![CDATA[
                <p>Contains the result of a successful invocation of the <a>CreateGroup</a> action.</p>
              ]]></xs:documentation>
            </xs:annotation>
            
          <xs:sequence>
            <xs:element name="Group" type="tns:Group">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Information about the group.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="CreateAccountAlias">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="AccountAlias" type="tns:accountAliasType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the account alias to create.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="CreateAccountAliasResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="DeleteUser">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="UserName" type="tns:existingUserNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the user to delete.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="DeleteUserResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="DeactivateMFADevice">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="UserName" type="tns:existingUserNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the user whose MFA device you want to deactivate.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="SerialNumber" type="tns:serialNumberType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The serial number that uniquely identifies the MFA device. For virtual MFA devices, the serial number is the device ARN.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="DeactivateMFADeviceResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="RemoveUserFromGroup">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="GroupName" type="tns:groupNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the group to update.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="UserName" type="tns:existingUserNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the user to remove.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="RemoveUserFromGroupResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="DeleteRole">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="RoleName" type="tns:roleNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the role to delete.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="DeleteRoleResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="DeleteServerCertificate">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="ServerCertificateName" type="tns:serverCertificateNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The name of the server certificate you want to delete.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="DeleteServerCertificateResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="CreateAccessKey">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="UserName" type="tns:existingUserNameType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The user name that the new key will belong to.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="CreateAccessKeyResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:CreateAccessKeyResult"/>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="CreateAccessKeyResult">
        <xs:complexType>

            <xs:annotation>
              <xs:documentation><![CDATA[
                <p>Contains the result of a successful invocation of the <a>CreateAccessKey</a> action.</p>
              ]]></xs:documentation>
            </xs:annotation>
            
          <xs:sequence>
            <xs:element name="AccessKey" type="tns:AccessKey">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Information about the access key.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="GetUser">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="UserName" type="tns:existingUserNameType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the user to get information about.</p>
              
                  <p>This parameter is optional. If it is not included, it defaults to the user making the request.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="GetUserResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:GetUserResult"/>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="GetUserResult">
        <xs:complexType>

            <xs:annotation>
              <xs:documentation><![CDATA[
                <p>Contains the result of a successful invocation of the <a>GetUser</a> action.</p>
              ]]></xs:documentation>
            </xs:annotation>
            
          <xs:sequence>
            <xs:element name="User" type="tns:User">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Information about the user.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ResyncMFADevice">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="UserName" type="tns:existingUserNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the user whose MFA device you want to resynchronize.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="SerialNumber" type="tns:serialNumberType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Serial number that uniquely identifies the MFA device.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="AuthenticationCode1" type="tns:authenticationCodeType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>An authentication code emitted by the device.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="AuthenticationCode2" type="tns:authenticationCodeType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>A subsequent authentication code emitted by the device.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ResyncMFADeviceResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListMFADevices">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="UserName" type="tns:existingUserNameType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the user whose MFA devices you want to list.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Marker" type="tns:markerType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Use this only when paginating results, and only in a subsequent request after you've received a response
                  where the results are truncated. Set it to the value of the <code>Marker</code> element in the response you just received.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="MaxItems" type="tns:maxItemsType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Use this only when paginating results to indicate the maximum number of MFA devices you want in the response. If there are
                  additional MFA devices beyond the maximum you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListMFADevicesResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ListMFADevicesResult"/>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListMFADevicesResult">
        <xs:complexType>

            <xs:annotation>
              <xs:documentation><![CDATA[
                <p>Contains the result of a successful invocation of the <a>ListMFADevices</a> action.</p>
              ]]></xs:documentation>
            </xs:annotation>
            
          <xs:sequence>
            <xs:element name="MFADevices" type="tns:mfaDeviceListType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>A list of MFA devices.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="IsTruncated" type="xs:boolean" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>A flag that indicates whether there are more MFA devices to list. If your results were truncated, you can make a
                  subsequent pagination request using the <code>Marker</code> request parameter to retrieve more MFA devices in the list.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Marker" type="tns:markerType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>If <code>IsTruncated</code> is <code>true</code>, this element is present and contains the value to use for
                  the <code>Marker</code> parameter in a subsequent pagination request.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="CreateVirtualMFADevice">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="Path" type="tns:pathType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The path for the virtual MFA device. For more information about paths, see 
              	<a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?Using_Identifiers.html" target="_blank">Identifiers for IAM Entities</a> in <i>Using AWS Identity and Access Management</i>.</p>
              
                  <p>This parameter is optional. If it is not included, it defaults to a slash (/).</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="VirtualMFADeviceName" type="tns:virtualMFADeviceName">

              <xs:annotation>
                <xs:documentation><![CDATA[
                    <p>The name of the virtual MFA device. Use with path to
                        uniquely identify a virtual MFA device.</p> 
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="CreateVirtualMFADeviceResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:CreateVirtualMFADeviceResult"/>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="CreateVirtualMFADeviceResult">
        <xs:complexType>

            <xs:annotation>
              <xs:documentation><![CDATA[
                <p>Contains the result of a successful invocation of the <a>CreateVirtualMFADevice</a> action.</p>
              ]]></xs:documentation>
            </xs:annotation>
            
          <xs:sequence>
            <xs:element name="VirtualMFADevice" type="tns:VirtualMFADevice">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>A newly created virtual MFA device.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListInstanceProfiles">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="PathPrefix" type="tns:pathPrefixType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The path prefix for filtering the results. For example: <code>/application_abc/component_xyz/</code>, which
                  would get all instance profiles whose path starts with <code>/application_abc/component_xyz/</code>.</p>
              
                  <p>This parameter is optional. If it is not included, it defaults to a slash (/), listing all instance profiles.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Marker" type="tns:markerType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Use this parameter only when paginating results, and only in a subsequent request after you've received a response where
                  the results are truncated. Set it to the value of the <code>Marker</code> element in the response you just received.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="MaxItems" type="tns:maxItemsType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Use this parameter only when paginating results to indicate the maximum number of user names you want in the response. If
                  there are additional user names beyond the maximum you specify, the <code>IsTruncated</code> response element 
                    is <code>true</code>.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListInstanceProfilesResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ListInstanceProfilesResult"/>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListInstanceProfilesResult">
        <xs:complexType>

            <xs:annotation>
              <xs:documentation><![CDATA[
                <p>Contains the result of a successful invocation of the <a>ListInstanceProfiles</a> action.</p>
              ]]></xs:documentation>
            </xs:annotation>
            
          <xs:sequence>
            <xs:element name="InstanceProfiles" type="tns:instanceProfileListType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>A list of instance profiles.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="IsTruncated" type="xs:boolean" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>A flag that indicates whether there are more instance profiles to list. If your results were truncated, you can make a
                  subsequent pagination request using the <code>Marker</code> request parameter to retrieve more instance profiles in the list.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Marker" type="tns:markerType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>If <code>IsTruncated</code> is <code>true</code>, this element is present and contains the value to use for
                  the <code>Marker</code> parameter in a subsequent pagination request.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="UpdateAccessKey">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="UserName" type="tns:existingUserNameType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the user whose key you want to update.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="AccessKeyId" type="tns:accessKeyIdType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The Access Key ID of the Secret Access Key you want to update.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Status" type="tns:statusType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The status you want to assign to the Secret Access Key. <code>Active</code> means the key can be used
                  for API calls to AWS, while <code>Inactive</code> means the key cannot be used.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="UpdateAccessKeyResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="AddUserToGroup">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="GroupName" type="tns:groupNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the group to update.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="UserName" type="tns:existingUserNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the user to add.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="AddUserToGroupResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="GetGroup">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="GroupName" type="tns:groupNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the group.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Marker" type="tns:markerType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Use this only when paginating results, and only in a subsequent request after you've received a response
                  where the results are truncated. Set it to the value of the <code>Marker</code> element in the response you just received.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="MaxItems" type="tns:maxItemsType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Use this only when paginating results to indicate the maximum number of user names you want in the response.
                  If there are additional user names beyond the maximum you specify, the <code>IsTruncated</code> response element is 
                  <code>true</code>.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="GetGroupResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:GetGroupResult"/>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="GetGroupResult">
        <xs:complexType>

            <xs:annotation>
              <xs:documentation><![CDATA[
                <p>Contains the result of a successful invocation of the <a>GetGroup</a> action.</p>
              ]]></xs:documentation>
            </xs:annotation>
            
          <xs:sequence>
            <xs:element name="Group" type="tns:Group">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Information about the group.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Users" type="tns:userListType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>A list of users in the group.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="IsTruncated" type="xs:boolean" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>A flag that indicates whether there are more user names to list. If your results were truncated, you can make a
                  subsequent pagination request using the <code>Marker</code> request parameter to retrieve more user names in the list.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Marker" type="tns:markerType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>If IsTruncated is <code>true</code>, then this element is present and contains the value to use for the <code>Marker</code> parameter in
                  a subsequent pagination request.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListAccountAliases">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="Marker" type="tns:markerType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Use this only when paginating results, and only in a subsequent request after you've received a
                  response where the results are truncated. Set it to the value of the <code>Marker</code> element in
                  the response you just received.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="MaxItems" type="tns:maxItemsType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Use this only when paginating results to indicate the maximum number of account aliases you want in 
                  the response. If there are additional account aliases beyond the maximum you specify, the <code>IsTruncated</code>
                  response element is <code>true</code>.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListAccountAliasesResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ListAccountAliasesResult"/>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListAccountAliasesResult">
        <xs:complexType>

            <xs:annotation>
              <xs:documentation><![CDATA[
                <p>Contains the result of a successful invocation of the <a>ListAccountAliases</a> action.</p>
              ]]></xs:documentation>
            </xs:annotation>
            
          <xs:sequence>
            <xs:element name="AccountAliases" type="tns:accountAliasListType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>A list of aliases associated with the account.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="IsTruncated" type="xs:boolean" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>A flag that indicates whether there are more account aliases to list. If your results were truncated,
                  you can make a subsequent pagination request using the <code>Marker</code> request parameter to retrieve
                  more account aliases in the list.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Marker" type="tns:markerType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Use this only when paginating results, and only in a subsequent request after you've received a
                    response where the results are truncated. Set it to the value of the <code>Marker</code> element in
                    the response you just received.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="DeleteGroup">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="GroupName" type="tns:groupNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the group to delete.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="DeleteGroupResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="GetRole">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="RoleName" type="tns:roleNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the role to get information about.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="GetRoleResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:GetRoleResult"/>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="GetRoleResult">
        <xs:complexType>

            <xs:annotation>
              <xs:documentation><![CDATA[
                <p>Contains the result of a successful invocation of the <a>GetRole</a> action.</p>
              ]]></xs:documentation>
            </xs:annotation>
            
          <xs:sequence>
            <xs:element name="Role" type="tns:Role">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Information about the role.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListRolePolicies">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="RoleName" type="tns:roleNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The name of the role to list policies for.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Marker" type="tns:markerType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Use this parameter only when paginating results, and only in a subsequent request after you've received a response where
                  the results are truncated. Set it to the value of the <code>Marker</code> element in the response you just received.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="MaxItems" type="tns:maxItemsType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Use this parameter only when paginating results to indicate the maximum number of user names you want in the response. If
                  there are additional user names beyond the maximum you specify, the <code>IsTruncated</code> response element 
                    is <code>true</code>.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListRolePoliciesResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ListRolePoliciesResult"/>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListRolePoliciesResult">
        <xs:complexType>

            <xs:annotation>
              <xs:documentation><![CDATA[
                <p>Contains the result of a successful invocation of the <a>ListRolePolicies</a> action.</p>
              ]]></xs:documentation>
            </xs:annotation>
            
          <xs:sequence>
            <xs:element name="PolicyNames" type="tns:policyNameListType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>A list of policy names.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="IsTruncated" type="xs:boolean" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>A flag that indicates whether there are more policy names to list. If your results were truncated, you can make a
                  subsequent pagination request using the <code>Marker</code> request parameter to retrieve more policy names in the list.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Marker" type="tns:markerType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>If <code>IsTruncated</code> is <code>true</code>, this element is present and contains the value to use for
                  the <code>Marker</code> parameter in a subsequent pagination request.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListSigningCertificates">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="UserName" type="tns:existingUserNameType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The name of the user.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Marker" type="tns:markerType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Use this only when paginating results, and only in a subsequent request after you've received a
                  response where the results are truncated. Set it to the value of the <code>Marker</code> element in
                  the response you just received.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="MaxItems" type="tns:maxItemsType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Use this only when paginating results to indicate the maximum number of certificate IDs you want in 
                  the response. If there are additional certificate IDs beyond the maximum you specify, the <code>IsTruncated</code>
                  response element is <code>true</code>.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListSigningCertificatesResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ListSigningCertificatesResult"/>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListSigningCertificatesResult">
        <xs:complexType>

            <xs:annotation>
              <xs:documentation><![CDATA[
                <p>Contains the result of a successful invocation of the <a>ListSigningCertificates</a> action.</p>
              ]]></xs:documentation>
            </xs:annotation>
            
          <xs:sequence>
            <xs:element name="Certificates" type="tns:certificateListType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>A list of the user's signing certificate information.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="IsTruncated" type="xs:boolean" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>A flag that indicates whether there are more certificate IDs to list. If your results were truncated,
                  you can make a subsequent pagination request using the <code>Marker</code> request parameter to retrieve
                  more certificates in the list.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Marker" type="tns:markerType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>If <code>IsTruncated</code> is <code>true</code>, this element is present and contains the value to use for the 
                  <code>Marker</code> parameter in a subsequent pagination request.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="UploadSigningCertificate">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="UserName" type="tns:existingUserNameType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the user the signing certificate is for.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="CertificateBody" type="tns:certificateBodyType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The contents of the signing certificate.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="UploadSigningCertificateResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:UploadSigningCertificateResult"/>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="UploadSigningCertificateResult">
        <xs:complexType>

            <xs:annotation>
              <xs:documentation><![CDATA[
                <p>Contains the result of a successful invocation of the <a>UploadSigningCertificate</a> action.</p>
              ]]></xs:documentation>
            </xs:annotation>
            
          <xs:sequence>
            <xs:element name="Certificate" type="tns:SigningCertificate">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Information about the certificate.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="DeleteInstanceProfile">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="InstanceProfileName" type="tns:instanceProfileNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the instance profile to delete.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="DeleteInstanceProfileResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="CreateRole">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="Path" type="tns:pathType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The path to the role. For more information about paths, see <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?Using_Identifiers.html" target="_blank">Identifiers for IAM Entities</a> in <i>Using AWS Identity and Access Management</i>.</p>
              
                  <p>This parameter is optional. If it is not included, it defaults to a slash (/).</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="RoleName" type="tns:roleNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the role to create.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="AssumeRolePolicyDocument" type="tns:policyDocumentType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The policy govering by who and under what conditions the role can be assumed.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="CreateRoleResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:CreateRoleResult"/>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="CreateRoleResult">
        <xs:complexType>

            <xs:annotation>
              <xs:documentation><![CDATA[
                <p>Contains the result of a successful invocation of the <a>CreateRole</a> action.</p>
              ]]></xs:documentation>
            </xs:annotation>
            
          <xs:sequence>
            <xs:element name="Role" type="tns:Role">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Information about the role.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="UpdateLoginProfile">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="UserName" type="tns:userNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the user whose password you want to update.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Password" type="tns:passwordType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The new password for the user name.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="UpdateLoginProfileResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="DeleteLoginProfile">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="UserName" type="tns:userNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the user whose password you want to delete.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="DeleteLoginProfileResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ChangePassword">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="OldPassword" type="tns:passwordType"/>
            <xs:element name="NewPassword" type="tns:passwordType"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ChangePasswordResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="GetServerCertificate">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="ServerCertificateName" type="tns:serverCertificateNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The name of the server certificate you want to retrieve information about.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="GetServerCertificateResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:GetServerCertificateResult"/>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="GetServerCertificateResult">
        <xs:complexType>

            <xs:annotation>
              <xs:documentation><![CDATA[
                <p>Contains the result of a successful invocation of the <a>GetServerCertificate</a> action.</p>
              ]]></xs:documentation>
            </xs:annotation>
            
          <xs:sequence>
            <xs:element name="ServerCertificate" type="tns:ServerCertificate">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Information about the server certificate.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="PutGroupPolicy">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="GroupName" type="tns:groupNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the group to associate the policy with.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="PolicyName" type="tns:policyNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the policy document.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="PolicyDocument" type="tns:policyDocumentType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The policy document.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="PutGroupPolicyResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="DeleteSigningCertificate">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="UserName" type="tns:existingUserNameType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the user the signing certificate belongs to.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="CertificateId" type="tns:certificateIdType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>ID of the signing certificate to delete.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="DeleteSigningCertificateResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListUserPolicies">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="UserName" type="tns:existingUserNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The name of the user to list policies for.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Marker" type="tns:markerType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Use this only when paginating results, and only in a subsequent request after you've received a response where the results 
                  are truncated. Set it to the value of the <code>Marker</code> element in the response you just received.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="MaxItems" type="tns:maxItemsType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Use this only when paginating results to indicate the maximum number of policy names you want in the response.
                  If there are additional policy names beyond the maximum you specify, the <code>IsTruncated</code> response element is
                  <code>true</code>.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListUserPoliciesResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ListUserPoliciesResult"/>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListUserPoliciesResult">
        <xs:complexType>

            <xs:annotation>
              <xs:documentation><![CDATA[
                <p>Contains the result of a successful invocation of the <a>ListUserPolicies</a> action.</p>
              ]]></xs:documentation>
            </xs:annotation>
            
          <xs:sequence>
            <xs:element name="PolicyNames" type="tns:policyNameListType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>A list of policy names.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="IsTruncated" type="xs:boolean" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>A flag that indicates whether there are more policy names to list. If your results were truncated,
                  you can make a subsequent pagination request using the <code>Marker</code> request parameter to retrieve
                  more policy names in the list.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Marker" type="tns:markerType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>If <code>IsTruncated</code> is <code>true</code>, this element is present and contains the value to 
                  use for the <code>Marker</code> parameter in a subsequent pagination request.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListAccessKeys">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="UserName" type="tns:existingUserNameType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the user.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Marker" type="tns:markerType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Use this parameter only when paginating results, and only in a subsequent request after you've received a response
                  where the results are truncated. Set it to the value of the <code>Marker</code> element in the response you just received.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="MaxItems" type="tns:maxItemsType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Use this parameter only when paginating results to indicate the maximum number of keys you want in the response. If there are
                    additional keys beyond the maximum you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListAccessKeysResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ListAccessKeysResult"/>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListAccessKeysResult">
        <xs:complexType>

            <xs:annotation>
              <xs:documentation><![CDATA[
                <p>Contains the result of a successful invocation of the <a>ListAccessKeys</a> action.</p>
              ]]></xs:documentation>
            </xs:annotation>
            
          <xs:sequence>
            <xs:element name="AccessKeyMetadata" type="tns:accessKeyMetadataListType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>A list of access key metadata.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="IsTruncated" type="xs:boolean" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>A flag that indicates whether there are more keys to list. If your results were truncated, you can make a subsequent
                  pagination request using the <code>Marker</code> request parameter to retrieve more keys in the list.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Marker" type="tns:markerType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>If <code>IsTruncated</code> is <code>true</code>, this element is present and contains the value to use for the <code>Marker</code>
                  parameter in a subsequent pagination request.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListGroupsForUser">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="UserName" type="tns:existingUserNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The name of the user to list groups for.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Marker" type="tns:markerType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Use this only when paginating results, and only in a subsequent request after you've received a response where
                  the results are truncated. Set it to the value of the <code>Marker</code> element in the response you just received.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="MaxItems" type="tns:maxItemsType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Use this only when paginating results to indicate the maximum number of groups you want in the response.
                  If there are additional groups beyond the maximum you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListGroupsForUserResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ListGroupsForUserResult"/>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListGroupsForUserResult">
        <xs:complexType>

            <xs:annotation>
              <xs:documentation><![CDATA[
                <p>Contains the result of a successful invocation of the <a>ListGroupsForUser</a> action.</p>
              ]]></xs:documentation>
            </xs:annotation>
            
          <xs:sequence>
            <xs:element name="Groups" type="tns:groupListType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>A list of groups.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="IsTruncated" type="xs:boolean" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>A flag that indicates whether there are more groups to list. If your results were truncated,
                  you can make a subsequent pagination request using the <code>Marker</code> request parameter to retrieve more
                  groups in the list.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Marker" type="tns:markerType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>If <code>IsTruncated</code> is <code>true</code>, this element is present and contains the value to use 
                    for the <code>Marker</code> parameter in a subsequent pagination request.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="AddRoleToInstanceProfile">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="InstanceProfileName" type="tns:instanceProfileNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the instance profile to update.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="RoleName" type="tns:roleNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the role to add.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="AddRoleToInstanceProfileResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="GetGroupPolicy">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="GroupName" type="tns:groupNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the group the policy is associated with.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="PolicyName" type="tns:policyNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the policy document to get.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="GetGroupPolicyResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:GetGroupPolicyResult"/>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="GetGroupPolicyResult">
        <xs:complexType>

            <xs:annotation>
              <xs:documentation><![CDATA[
                <p>Contains the result of a successful invocation of the <a>GetGroupPolicy</a> action.</p>
              ]]></xs:documentation>
            </xs:annotation>
            
          <xs:sequence>
            <xs:element name="GroupName" type="tns:groupNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The group the policy is associated with.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="PolicyName" type="tns:policyNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The name of the policy.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="PolicyDocument" type="tns:policyDocumentType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The policy document.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="GetRolePolicy">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="RoleName" type="tns:roleNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the role who the policy is associated with.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="PolicyName" type="tns:policyNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the policy document to get.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="GetRolePolicyResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:GetRolePolicyResult"/>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="GetRolePolicyResult">
        <xs:complexType>

            <xs:annotation>
              <xs:documentation><![CDATA[
                <p>Contains the result of a successful invocation of the <a>GetRolePolicy</a> action.</p>
              ]]></xs:documentation>
            </xs:annotation>
            
          <xs:sequence>
            <xs:element name="RoleName" type="tns:roleNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The role the policy is associated with.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="PolicyName" type="tns:policyNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The name of the policy.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="PolicyDocument" type="tns:policyDocumentType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The policy document.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListInstanceProfilesForRole">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="RoleName" type="tns:roleNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The name of the role to list instance profiles for.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Marker" type="tns:markerType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Use this parameter only when paginating results, and only in a subsequent request after you've received a response where
                  the results are truncated. Set it to the value of the <code>Marker</code> element in the response you just received.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="MaxItems" type="tns:maxItemsType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Use this parameter only when paginating results to indicate the maximum number of user names you want in the response. If
                  there are additional user names beyond the maximum you specify, the <code>IsTruncated</code> response element 
                    is <code>true</code>.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListInstanceProfilesForRoleResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ListInstanceProfilesForRoleResult"/>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListInstanceProfilesForRoleResult">
        <xs:complexType>

            <xs:annotation>
              <xs:documentation><![CDATA[
                <p>Contains the result of a successful invocation of the <a>ListInstanceProfilesForRole</a> action.</p>
              ]]></xs:documentation>
            </xs:annotation>
            
          <xs:sequence>
            <xs:element name="InstanceProfiles" type="tns:instanceProfileListType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>A list of instance profiles.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="IsTruncated" type="xs:boolean" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>A flag that indicates whether there are more instance profiles to list. If your results were truncated, you can make a
                  subsequent pagination request using the <code>Marker</code> request parameter to retrieve more instance profiles in the list.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Marker" type="tns:markerType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>If <code>IsTruncated</code> is <code>true</code>, this element is present and contains the value to use for
                  the <code>Marker</code> parameter in a subsequent pagination request.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListVirtualMFADevices">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="AssignmentStatus" type="tns:assignmentStatusType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                    <p>The status (unassigned or assigned) of the devices to list.
                    If you do not specify an <code>AssignmentStatus</code>, the action defaults to <code>Any</code> which 
                    lists both assigned and unassigned virtual MFA devices.
                    </p> 
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Marker" type="tns:markerType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Use this parameter only when paginating results, and only in a subsequent request after you've received a response where
                    the results are truncated. Set it to the value of the <code>Marker</code> element in the response you just received.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="MaxItems" type="tns:maxItemsType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Use this parameter only when paginating results to indicate the maximum number of user names you want in the response. If
                    there are additional user names beyond the maximum you specify, the <code>IsTruncated</code> response element is <code>true</code>.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListVirtualMFADevicesResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ListVirtualMFADevicesResult"/>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListVirtualMFADevicesResult">
        <xs:complexType>

            <xs:annotation>
              <xs:documentation><![CDATA[
                <p>Contains the result of a successful invocation of the <a>ListVirtualMFADevices</a> action.</p>
              ]]></xs:documentation>
            </xs:annotation>
            
          <xs:sequence>
            <xs:element name="VirtualMFADevices" type="tns:virtualMFADeviceListType"/>
            <xs:element name="IsTruncated" type="xs:boolean" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>A flag that indicates whether there are more items to list. If your results were truncated, you can make a
                    subsequent pagination request using the <code>Marker</code> request parameter to retrieve more items the list.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Marker" type="tns:markerType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>If <code>IsTruncated</code> is <code>true</code>, this element is present and contains the value to use for
                    the <code>Marker</code> parameter in a subsequent pagination request.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="DeleteRolePolicy">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="RoleName" type="tns:roleNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the role the policy is associated with.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="PolicyName" type="tns:policyNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the policy document to delete.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="DeleteRolePolicyResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="CreateInstanceProfile">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="InstanceProfileName" type="tns:instanceProfileNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the instance profile to create.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Path" type="tns:pathType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The path to the instance profile. For more information about paths, see <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?Using_Identifiers.html" target="_blank">Identifiers for IAM Entities</a> in <i>Using AWS Identity and Access Management</i>.</p>
              
                  <p>This parameter is optional. If it is not included, it defaults to a slash (/).</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="CreateInstanceProfileResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:CreateInstanceProfileResult"/>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="CreateInstanceProfileResult">
        <xs:complexType>

            <xs:annotation>
              <xs:documentation><![CDATA[
                <p>Contains the result of a successful invocation of the <a>CreateInstanceProfile</a> action.</p>
              ]]></xs:documentation>
            </xs:annotation>
            
          <xs:sequence>
            <xs:element name="InstanceProfile" type="tns:InstanceProfile">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Information about the instance profile.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListGroupPolicies">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="GroupName" type="tns:groupNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The name of the group to list policies for.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Marker" type="tns:markerType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Use this only when paginating results, and only in a subsequent request after you've received a response where the results 
                  are truncated. Set it to the value of the <code>Marker</code> element in the response you just received.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="MaxItems" type="tns:maxItemsType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Use this only when paginating results to indicate the maximum number of policy names you want in the response.
                  If there are additional policy names beyond the maximum you specify, the <code>IsTruncated</code> response element is
                  <code>true</code>.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListGroupPoliciesResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ListGroupPoliciesResult"/>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListGroupPoliciesResult">
        <xs:complexType>

            <xs:annotation>
              <xs:documentation><![CDATA[
                <p>Contains the result of a successful invocation of the <a>ListGroupPolicies</a> action.</p>
              ]]></xs:documentation>
            </xs:annotation>
            
          <xs:sequence>
            <xs:element name="PolicyNames" type="tns:policyNameListType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>A list of policy names.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="IsTruncated" type="xs:boolean" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>A flag that indicates whether there are more policy names to list. If your results were truncated,
                  you can make a subsequent pagination request using the <code>Marker</code> request parameter to retrieve
                  more policy names in the list.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Marker" type="tns:markerType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>If <code>IsTruncated</code> is <code>true</code>, this element is present and contains the value to 
                  use for the <code>Marker</code> parameter in a subsequent pagination request.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="CreateLoginProfile">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="UserName" type="tns:userNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the user to create a password for.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Password" type="tns:passwordType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The new password for the user name.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="CreateLoginProfileResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:CreateLoginProfileResult"/>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="CreateLoginProfileResult">
        <xs:complexType>

            <xs:annotation>
              <xs:documentation><![CDATA[
                <p>Contains the result of a successful invocation of the <a>CreateLoginProfile</a> action.</p>
              ]]></xs:documentation>
            </xs:annotation>
            
          <xs:sequence>
            <xs:element name="LoginProfile" type="tns:LoginProfile">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The user name and password create date.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="RemoveRoleFromInstanceProfile">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="InstanceProfileName" type="tns:instanceProfileNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the instance profile to update.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="RoleName" type="tns:roleNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the role to remove.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="RemoveRoleFromInstanceProfileResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="UpdateAccountPasswordPolicy">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="MinimumPasswordLength" type="tns:minimumPasswordLengthType" minOccurs="0"/>
            <xs:element name="RequireSymbols" type="xs:boolean" minOccurs="0"/>
            <xs:element name="RequireNumbers" type="xs:boolean" minOccurs="0"/>
            <xs:element name="RequireUppercaseCharacters" type="xs:boolean" minOccurs="0"/>
            <xs:element name="RequireLowercaseCharacters" type="xs:boolean" minOccurs="0"/>
            <xs:element name="AllowUsersToChangePassword" type="xs:boolean" minOccurs="0"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="UpdateAccountPasswordPolicyResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="UpdateAssumeRolePolicy">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="RoleName" type="tns:roleNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the role to update.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="PolicyDocument" type="tns:policyDocumentType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The policy govering by who and under what conditions the role can be assumed.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="UpdateAssumeRolePolicyResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="GetInstanceProfile">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="InstanceProfileName" type="tns:instanceProfileNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the instance profile to get information about.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="GetInstanceProfileResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:GetInstanceProfileResult"/>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="GetInstanceProfileResult">
        <xs:complexType>

            <xs:annotation>
              <xs:documentation><![CDATA[
                <p>Contains the result of a successful invocation of the <a>GetInstanceProfile</a> action.</p>
              ]]></xs:documentation>
            </xs:annotation>
            
          <xs:sequence>
            <xs:element name="InstanceProfile" type="tns:InstanceProfile">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Information about the instance profile.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListRoles">
        <xs:complexType>

          <xs:annotation>
            <xs:documentation><![CDATA[ ]]></xs:documentation>
          </xs:annotation>
          
          <xs:sequence>
            <xs:element name="PathPrefix" type="tns:pathPrefixType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The path prefix for filtering the results. For example: <code>/application_abc/component_xyz/</code>, which
                  would get all roles whose path starts with <code>/application_abc/component_xyz/</code>.</p>
              
                  <p>This parameter is optional. If it is not included, it defaults to a slash (/), listing all roles.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Marker" type="tns:markerType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Use this parameter only when paginating results, and only in a subsequent request after you've received a response where
                  the results are truncated. Set it to the value of the <code>Marker</code> element in the response you just received.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="MaxItems" type="tns:maxItemsType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Use this parameter only when paginating results to indicate the maximum number of user names you want in the response. If
                  there are additional user names beyond the maximum you specify, the <code>IsTruncated</code> response element 
                    is <code>true</code>.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListRolesResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:ListRolesResult"/>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="ListRolesResult">
        <xs:complexType>

            <xs:annotation>
              <xs:documentation><![CDATA[
                <p>Contains the result of a successful invocation of the <a>ListRoles</a> action.</p>
              ]]></xs:documentation>
            </xs:annotation>
            
          <xs:sequence>
            <xs:element name="Roles" type="tns:roleListType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>A list of roles.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="IsTruncated" type="xs:boolean" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>A flag that indicates whether there are more roles to list. If your results were truncated, you can make a
                  subsequent pagination request using the <code>Marker</code> request parameter to retrieve more roles in the list.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Marker" type="tns:markerType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>If <code>IsTruncated</code> is <code>true</code>, this element is present and contains the value to use for
                  the <code>Marker</code> parameter in a subsequent pagination request.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="GetAccountSummary">
        <xs:complexType>
          <xs:sequence>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="GetAccountSummaryResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:GetAccountSummaryResult"/>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="GetAccountSummaryResult">
        <xs:complexType>

            <xs:annotation>
              <xs:documentation><![CDATA[
                <p>Contains the result of a successful invocation of the <a>GetAccountSummary</a> action.</p>
              ]]></xs:documentation>
            </xs:annotation>
            
          <xs:sequence>
            <xs:element name="SummaryMap" type="tns:summaryMapType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>A set of key value pairs containing account-level information.</p>
              
                  <p>
                    <code>SummaryMap</code> contains the following keys:
                    <ul>
                      <li><p><code>AccessKeysPerUserQuota</code> - Maximum number of access keys that can be created per user</p></li>
                      <li><p><code>AccountMFAEnabled</code> - 1 if the root account has an MFA device assigned to it, 0 otherwise</p></li>
                      <li><p><code>AssumeRolePolicySizeQuota</code> - Maximum allowed size for assume role policy documents (in kilobytes) </p></li>
                      <li><p><code>GroupPolicySizeQuota</code> - Maximum allowed size for Group policy documents (in kilobytes)</p></li>
                      <li><p><code>Groups</code> - Number of Groups for the AWS account</p></li>
                      <li><p><code>GroupsPerUserQuota</code> - Maximum number of groups a user can belong to</p></li>
                      <li><p><code>GroupsQuota</code> - Maximum groups allowed for the AWS account</p></li>
                      <li><p><code>InstanceProfiles</code> - Number of instance profiles for the AWS account</p></li>
                      <li><p><code>InstanceProfilesQuota</code> - Maximum instance profiles allowed for the AWS account</p></li>
                      <li><p><code>MFADevices</code> - Number of MFA devices, either assigned or unassigned</p></li>
                      <li><p><code>MFADevicesInUse</code> - Number of MFA devices that have been assigned to an IAM user or to the root account</p></li>
                      <li><p><code>RolePolicySizeQuota</code> - Maximum allowed size for role policy documents (in kilobytes) </p></li>
                      <li><p><code>Roles</code> - Number of roles for the AWS account</p></li>
                      <li><p><code>RolesQuota</code> - Maximum roles allowed for the AWS account</p></li>
                      <li><p><code>ServerCertificates</code> - Number of server certificates for the AWS account</p></li>
                      <li><p><code>ServerCertificatesQuota</code> - Maximum server certificates allowed for the AWS account</p></li>
                      <li><p><code>SigningCertificatesPerUserQuota</code> - Maximum number of X509 certificates allowed for a user</p></li>
                      <li><p><code>UserPolicySizeQuota</code> - Maximum allowed size for user policy documents (in kilobytes) </p></li>
                      <li><p><code>Users</code> - Number of users for the AWS account</p></li>
                      <li><p><code>UsersQuota</code> - Maximum users allowed for the AWS account</p></li>
                    </ul>
                  </p>
              
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="GetAccountPasswordPolicy">
        <xs:complexType>
          <xs:sequence>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="GetAccountPasswordPolicyResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element ref="tns:GetAccountPasswordPolicyResult"/>
            <xs:element ref="tns:ResponseMetadata" minOccurs="1"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="GetAccountPasswordPolicyResult">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="PasswordPolicy" type="tns:PasswordPolicy"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:simpleType name="statusType">
        <xs:restriction base="xs:string">
          <xs:enumeration value="Active"/>
          <xs:enumeration value="Inactive"/>
        </xs:restriction>
      </xs:simpleType>

      <xs:simpleType name="policyNameType">
        <xs:restriction base="xs:string">
          <xs:pattern value="[\w+=,.@-]*"/>
          <xs:minLength value="1"/>
          <xs:maxLength value="128"/>
        </xs:restriction>
      </xs:simpleType>

      <xs:simpleType name="markerType">
        <xs:restriction base="xs:string">
          <xs:pattern value="[\u0020-\u00FF]*"/>
          <xs:minLength value="1"/>
          <xs:maxLength value="320"/>
        </xs:restriction>
      </xs:simpleType>

      <xs:simpleType name="pathPrefixType">
        <xs:restriction base="xs:string">
          <xs:pattern value="\u002F[\u0021-\u007F]*"/>
          <xs:minLength value="1"/>
          <xs:maxLength value="512"/>
        </xs:restriction>
      </xs:simpleType>

      <xs:simpleType name="instanceProfileNameType">
        <xs:restriction base="xs:string">
          <xs:pattern value="[\w+=,.@-]*"/>
          <xs:minLength value="1"/>
          <xs:maxLength value="128"/>
        </xs:restriction>
      </xs:simpleType>

      <xs:complexType name="accountAliasListType">
        <xs:sequence>
          <xs:element name="member" type="tns:accountAliasType" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:complexType>

      <xs:simpleType name="maxItemsType">
        <xs:restriction base="xs:integer">
        </xs:restriction>
      </xs:simpleType>

      <xs:simpleType name="certificateBodyType">
        <xs:restriction base="xs:string">
          <xs:pattern value="[\u0009\u000A\u000D\u0020-\u00FF]+"/>
          <xs:minLength value="1"/>
          <xs:maxLength value="16384"/>
        </xs:restriction>
      </xs:simpleType>

      <xs:simpleType name="certificateChainType">
        <xs:restriction base="xs:string">
          <xs:pattern value="[\u0009\u000A\u000D\u0020-\u00FF]*"/>
          <xs:minLength value="1"/>
          <xs:maxLength value="2097152"/>
        </xs:restriction>
      </xs:simpleType>

      <xs:complexType name="roleListType">

        <xs:annotation>
          <xs:documentation><![CDATA[
            <p>The roleListType data type contains a list of roles.</p>
            
            <p>
            This data type is used as a response element in the action <a>ListRoles</a>.
            </p>
          ]]></xs:documentation>
        </xs:annotation>
        
        <xs:sequence>
          <xs:element name="member" type="tns:Role" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:complexType>

      <xs:complexType name="instanceProfileListType">

        <xs:annotation>
          <xs:documentation><![CDATA[
            <p>The instanceProfileListType data type contains a list of instance profiles.</p>
            
            <p>
            This data type is used as a response element in the actions <a>ListInstanceProfiles</a> and <a>ListInstanceProfilesForRole</a>.
            </p>
          ]]></xs:documentation>
        </xs:annotation>
        
        <xs:sequence>
          <xs:element name="member" type="tns:InstanceProfile" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:complexType>

      <xs:complexType name="User">

        <xs:annotation>
          <xs:documentation><![CDATA[
            <p>The User data type contains information about a user.</p>
            
            <p>
            This data type is used as a response element in the following actions:</p>
        	<ul>
              <li><p><a>CreateUser</a></p></li>
              <li><p><a>GetUser</a></p></li>
              <li><p><a>ListUsers</a></p></li> 
            </ul>
          ]]></xs:documentation>
        </xs:annotation>
        
        <xs:sequence>
            <xs:element name="Path" type="tns:pathType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Path to the user. For more information about paths, see <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?Using_Identifiers.html" target="_blank">Identifiers for IAM Entities</a> in <i>Using AWS Identity and Access Management</i>.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="UserName" type="tns:userNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The name identifying the user.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="UserId" type="tns:idType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The stable and unique string identifying the user. For more information about IDs, see <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?Using_Identifiers.html" target="_blank">Identifiers for IAM Entities</a> in <i>Using AWS Identity and Access Management</i>.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Arn" type="tns:arnType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The Amazon Resource Name (ARN) specifying the user. For more information about ARNs and how
                  to use them in policies, see <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?Using_Identifiers.html" target="_blank">Identifiers for IAM Entities</a> in <i>Using AWS Identity and Access Management</i>.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="CreateDate" type="xs:dateTime">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The date when the user was created.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
        </xs:sequence>
      </xs:complexType>

      <xs:simpleType name="roleNameType">
        <xs:restriction base="xs:string">
          <xs:pattern value="[\w+=,.@-]*"/>
          <xs:minLength value="1"/>
          <xs:maxLength value="64"/>
        </xs:restriction>
      </xs:simpleType>

      <xs:complexType name="virtualMFADeviceListType">
        <xs:sequence>
          <xs:element name="member" type="tns:VirtualMFADevice" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:complexType>

      <xs:complexType name="mfaDeviceListType">

        <xs:annotation>
          <xs:documentation><![CDATA[
            <p>Contains a list of MFA devices.</p>
        
            <p>
              This data type is used as a response element in the actions <a>ListMFADevices</a> and <a>ListVirtualMFADevices</a>.
            </p>
          ]]></xs:documentation>
        </xs:annotation>
        
        <xs:sequence>
          <xs:element name="member" type="tns:MFADevice" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:complexType>

      <xs:complexType name="summaryMapType">
        <xs:sequence>
          <xs:element name="entry" type="tns:summaryMapTypeEntry" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:complexType>

      <xs:complexType name="summaryMapTypeEntry">
        <xs:sequence>
          <xs:element name="key" type="tns:summaryKeyType" minOccurs="1"/>
          <xs:element name="value" type="xs:integer"/>
        </xs:sequence>
      </xs:complexType>

      <xs:simpleType name="serverCertificateNameType">
        <xs:restriction base="xs:string">
          <xs:pattern value="[\w+=,.@-]*"/>
          <xs:minLength value="1"/>
          <xs:maxLength value="128"/>
        </xs:restriction>
      </xs:simpleType>

      <xs:complexType name="userListType">

        <xs:annotation>
          <xs:documentation><![CDATA[
            <p>The userListType data type contains a list of users.</p>
            
            <p>
            This data type is used as a response element in the actions <a>GetGroup</a> and <a>ListUsers</a>.
            </p>
          ]]></xs:documentation>
        </xs:annotation>
        
        <xs:sequence>
          <xs:element name="member" type="tns:User" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:complexType>

      <xs:simpleType name="passwordType">
        <xs:restriction base="xs:string">
          <xs:pattern value="[\u0009\u000A\u000D\u0020-\u00FF]+"/>
          <xs:minLength value="1"/>
          <xs:maxLength value="128"/>
        </xs:restriction>
      </xs:simpleType>

      <xs:complexType name="AccessKeyMetadata">

        <xs:annotation>
          <xs:documentation><![CDATA[
            <p>The AccessKey data type contains information about an AWS access key, without its secret key.</p>
            
            <p>
            This data type is used as a response element in the action <a>ListAccessKeys</a>.
            </p>
          ]]></xs:documentation>
        </xs:annotation>
        
        <xs:sequence>
            <xs:element name="UserName" type="tns:userNameType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the user the key is associated with.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="AccessKeyId" type="tns:accessKeyIdType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The ID for this access key.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Status" type="tns:statusType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The status of the access key. <code>Active</code> means the key is valid for
                  API calls, while <code>Inactive</code> means it is not.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="CreateDate" type="xs:dateTime" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The date when the access key was created.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
        </xs:sequence>
      </xs:complexType>

      <xs:simpleType name="accountAliasType">
        <xs:restriction base="xs:string">
          <xs:pattern value="^[a-z0-9](([a-z0-9]|-(?!-))*[a-z0-9])?$"/>
          <xs:minLength value="3"/>
          <xs:maxLength value="63"/>
        </xs:restriction>
      </xs:simpleType>

      <xs:simpleType name="groupNameType">
        <xs:restriction base="xs:string">
          <xs:pattern value="[\w+=,.@-]*"/>
          <xs:minLength value="1"/>
          <xs:maxLength value="128"/>
        </xs:restriction>
      </xs:simpleType>

      <xs:complexType name="AccessKey">

        <xs:annotation>
          <xs:documentation><![CDATA[
            <p>The AccessKey data type contains information about an AWS access key.</p>
            
            <p>
            This data type is used as a response element in the actions <a>CreateAccessKey</a> and <a>ListAccessKeys</a>.
            </p>
          ]]></xs:documentation>
        </xs:annotation>
        
        <xs:sequence>
            <xs:element name="UserName" type="tns:userNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the user the key is associated with.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="AccessKeyId" type="tns:accessKeyIdType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The ID for this access key.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Status" type="tns:statusType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The status of the access key. <code>Active</code> means the key is valid for
                  API calls, while <code>Inactive</code> means it is not.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="SecretAccessKey" type="xs:string">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The secret key used to sign requests.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="CreateDate" type="xs:dateTime" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The date when the access key was created.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
        </xs:sequence>
      </xs:complexType>

      <xs:simpleType name="virtualMFADeviceName">
        <xs:restriction base="xs:string">
          <xs:pattern value="[\w+=,.@-]*"/>
          <xs:minLength value="1"/>
        </xs:restriction>
      </xs:simpleType>

      <xs:complexType name="InstanceProfile">

        <xs:annotation>
          <xs:documentation><![CDATA[
            <p>The InstanceProfile data type contains information about an instance profile.</p>
            
            <p>
            This data type is used as a response element in the following actions:</p>
        	<ul>
              <li><p><a>CreateInstanceProfile</a></p></li>
              <li><p><a>GetInstanceProfile</a></p></li>
              <li><p><a>ListsInstanceProfile</a></p></li> 
              <li><p><a>ListsInstanceProfilesForRole</a></p></li> 
            </ul>
          ]]></xs:documentation>
        </xs:annotation>
        
        <xs:sequence>
            <xs:element name="Path" type="tns:pathType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Path to the instance profile. For more information about paths, see <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?Using_Identifiers.html" target="_blank">Identifiers for IAM Entities</a> in <i>Using AWS Identity and Access Management</i>.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="InstanceProfileName" type="tns:instanceProfileNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The name identifying the instance profile.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="InstanceProfileId" type="tns:idType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The stable and unique string identifying the instance profile. For more information about IDs, see <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?Using_Identifiers.html" target="_blank">Identifiers for IAM Entities</a> in <i>Using AWS Identity and Access Management</i>.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Arn" type="tns:arnType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The Amazon Resource Name (ARN) specifying the instance profile. For more information about ARNs and how
                  to use them in policies, see <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?Using_Identifiers.html" target="_blank">Identifiers for IAM Entities</a> in <i>Using AWS Identity and Access Management</i>.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="CreateDate" type="xs:dateTime">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The date when the instance profile was created.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Roles" type="tns:roleListType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The role associated with the instance profile.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
        </xs:sequence>
      </xs:complexType>

      <xs:complexType name="serverCertificateMetadataListType">
        <xs:sequence>
          <xs:element name="member" type="tns:ServerCertificateMetadata" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:complexType>

      <xs:complexType name="ServerCertificate">

        <xs:annotation>
          <xs:documentation><![CDATA[
            <p>The ServerCertificate data type contains information about a server certificate.</p>
        
            <p>This data type is used as a response element in the action <a>GetServerCertificate</a>.</p>
          ]]></xs:documentation>
        </xs:annotation>
        
        <xs:sequence>
            <xs:element name="ServerCertificateMetadata" type="tns:ServerCertificateMetadata">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The meta information of the server certificate, such as its name, path, ID, and ARN.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="CertificateBody" type="tns:certificateBodyType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The contents of the public key certificate.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="CertificateChain" type="tns:certificateChainType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The contents of the public key certificate chain.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
        </xs:sequence>
      </xs:complexType>

      <xs:simpleType name="userNameType">
        <xs:restriction base="xs:string">
          <xs:pattern value="[\w+=,.@-]*"/>
          <xs:minLength value="1"/>
          <xs:maxLength value="64"/>
        </xs:restriction>
      </xs:simpleType>

      <xs:complexType name="groupListType">

        <xs:annotation>
          <xs:documentation><![CDATA[
            <p>The groupListType data type contains a list of groups.</p>
            
            <p>
            This data type is used as a response element in the action <a>ListGroups</a>.
            </p>
          ]]></xs:documentation>
        </xs:annotation>
        
        <xs:sequence>
          <xs:element name="member" type="tns:Group" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:complexType>

      <xs:complexType name="Role">

        <xs:annotation>
          <xs:documentation><![CDATA[
            <p>The Role data type contains information about a role.</p>
            
            <p>
            This data type is used as a response element in the following actions:</p>
        	<ul>
              <li><p><a>CreateRole</a></p></li>
              <li><p><a>GetRole</a></p></li>
              <li><p><a>ListRoles</a></p></li> 
            </ul>
          ]]></xs:documentation>
        </xs:annotation>
        
        <xs:sequence>
            <xs:element name="Path" type="tns:pathType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Path to the role. For more information about paths, see <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?Using_Identifiers.html" target="_blank">Identifiers for IAM Entities</a> in <i>Using AWS Identity and Access Management</i>.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="RoleName" type="tns:roleNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The name identifying the role.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="RoleId" type="tns:idType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The stable and unique string identifying the role. For more information about IDs, see <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?Using_Identifiers.html" target="_blank">Identifiers for IAM Entities</a> in <i>Using AWS Identity and Access Management</i>.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Arn" type="tns:arnType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The Amazon Resource Name (ARN) specifying the role. For more information about ARNs and how
                  to use them in policies, see <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?Using_Identifiers.html" target="_blank">Identifiers for IAM Entities</a> in <i>Using AWS Identity and Access Management</i>.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="CreateDate" type="xs:dateTime">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The date when the role was created.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="AssumeRolePolicyDocument" type="tns:policyDocumentType" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The policy govering by who and under what conditions the role can be assumed.</p>
              
                  <p>The returned policy is URL-encoded according to RFC 3986. For more information about
                     RFC 3986, go to <a href="http://www.faqs.org/rfcs/rfc3986.html">http://www.faqs.org/rfcs/rfc3986.html</a>.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
        </xs:sequence>
      </xs:complexType>

      <xs:simpleType name="assignmentStatusType">
        <xs:restriction base="xs:string">
          <xs:enumeration value="Assigned"/>
          <xs:enumeration value="Unassigned"/>
          <xs:enumeration value="Any"/>
        </xs:restriction>
      </xs:simpleType>

      <xs:complexType name="ServerCertificateMetadata">

        <xs:annotation>
          <xs:documentation><![CDATA[
            <p>ServerCertificateMetadata contains information about a server certificate without its certificate body, certificate chain, and private key.</p>
        
            <p>This data type is used as a response element in the action <a>UploadServerCertificate</a> and <a>ListServerCertificates</a>.</p>
          ]]></xs:documentation>
        </xs:annotation>
        
        <xs:sequence>
            <xs:element name="Path" type="tns:pathType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Path to the server certificate. For more information about paths, see <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?Using_Identifiers.html" target="_blank">Identifiers for IAM Entities</a> in <i>Using AWS Identity and Access Management</i>.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="ServerCertificateName" type="tns:serverCertificateNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The name that identifies the server certificate.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="ServerCertificateId" type="tns:idType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The stable and unique string identifying the server certificate. For more information about IDs, see <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?Using_Identifiers.html" target="_blank">Identifiers for IAM Entities</a> in <i>Using AWS Identity and Access Management</i>.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Arn" type="tns:arnType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The Amazon Resource Name (ARN) specifying the server certificate. For more information about ARNs and how
                  to use them in policies, see <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?Using_Identifiers.html" target="_blank">Identifiers for IAM Entities</a> in <i>Using AWS Identity and Access Management</i>.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="UploadDate" type="xs:dateTime" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The date when the server certificate was uploaded.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
        </xs:sequence>
      </xs:complexType>

      <xs:complexType name="VirtualMFADevice">

        <xs:annotation>
          <xs:documentation><![CDATA[
            <p>The <code>VirtualMFADevice</code> data type contains information about a virtual MFA device.</p>
          ]]></xs:documentation>
        </xs:annotation>
        
        <xs:sequence>
            <xs:element name="SerialNumber" type="tns:serialNumberType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The serial number associated with <code>VirtualMFADevice</code>.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Base32StringSeed" type="xs:base64Binary" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The Base32 seed defined as specified in <a href="http://www.ietf.org/rfc/rfc3548.txt" target="_blank">RFC3548</a>. 
                   The <code>Base32StringSeed</code> is Base64-encoded.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="QRCodePNG" type="xs:base64Binary" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>A QR code PNG image that encodes 
                    <i>otpauth://totp/$virtualMFADeviceName@$AccountName?
                      secret=$Base32String</i>
                     where $virtualMFADeviceName is one of the create call arguments, AccountName is the user name if set 
                     (accountId otherwise), and Base32String is the seed in Base32 format. The <code>Base32String</code> is Base64-encoded.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="User" type="tns:User" minOccurs="0"/>
            <xs:element name="EnableDate" type="xs:dateTime" minOccurs="0"/>
        </xs:sequence>
      </xs:complexType>

      <xs:complexType name="SigningCertificate">

        <xs:annotation>
          <xs:documentation><![CDATA[
            <p>The SigningCertificate data type contains information about an X.509 signing certificate.</p>
            
            <p>
            This data type is used as a response element in the actions <a>UploadSigningCertificate</a> and <a>ListSigningCertificates</a>.
            </p>
          ]]></xs:documentation>
        </xs:annotation>
        
        <xs:sequence>
            <xs:element name="UserName" type="tns:userNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Name of the user the signing certificate is associated with.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="CertificateId" type="tns:certificateIdType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The ID for the signing certificate.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="CertificateBody" type="tns:certificateBodyType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The contents of the signing certificate.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Status" type="tns:statusType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The status of the signing certificate. <code>Active</code> means the key is valid for
                  API calls, while <code>Inactive</code> means it is not.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="UploadDate" type="xs:dateTime" minOccurs="0">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The date when the signing certificate was uploaded.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
        </xs:sequence>
      </xs:complexType>

      <xs:simpleType name="minimumPasswordLengthType">
        <xs:restriction base="xs:integer">
        </xs:restriction>
      </xs:simpleType>

      <xs:simpleType name="policyDocumentType">
        <xs:restriction base="xs:string">
          <xs:pattern value="[\u0009\u000A\u000D\u0020-\u00FF]+"/>
          <xs:minLength value="1"/>
          <xs:maxLength value="131072"/>
        </xs:restriction>
      </xs:simpleType>

      <xs:complexType name="PasswordPolicy">
        <xs:sequence>
            <xs:element name="MinimumPasswordLength" type="tns:minimumPasswordLengthType" minOccurs="0"/>
            <xs:element name="RequireSymbols" type="xs:boolean" minOccurs="0"/>
            <xs:element name="RequireNumbers" type="xs:boolean" minOccurs="0"/>
            <xs:element name="RequireUppercaseCharacters" type="xs:boolean" minOccurs="0"/>
            <xs:element name="RequireLowercaseCharacters" type="xs:boolean" minOccurs="0"/>
            <xs:element name="AllowUsersToChangePassword" type="xs:boolean" minOccurs="0"/>
        </xs:sequence>
      </xs:complexType>

      <xs:complexType name="Group">

        <xs:annotation>
          <xs:documentation><![CDATA[
            <p>The Group data type contains information about a group.</p>
            
        	<p>
            This data type is used as a response element in the following actions:</p>
            <ul>
        	  <li><a>CreateGroup</a></li>
        	  <li><a>GetGroup</a></li>
        	  <li><a>ListGroups</a></li>
            </ul>
          ]]></xs:documentation>
        </xs:annotation>
        
        <xs:sequence>
            <xs:element name="Path" type="tns:pathType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>Path to the group. For more information about paths, see <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?Using_Identifiers.html" target="_blank">Identifiers for IAM Entities</a> in <i>Using AWS Identity and Access Management</i>.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="GroupName" type="tns:groupNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The name that identifies the group.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="GroupId" type="tns:idType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The stable and unique string identifying the group. For more information about IDs, see <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?Using_Identifiers.html" target="_blank">Identifiers for IAM Entities</a> in <i>Using AWS Identity and Access Management</i>.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="Arn" type="tns:arnType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The Amazon Resource Name (ARN) specifying the group. For more information about ARNs and how
                  to use them in policies, see <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?Using_Identifiers.html" target="_blank">Identifiers for IAM Entities</a> in <i>Using AWS Identity and Access Management</i>.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="CreateDate" type="xs:dateTime">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The date when the group was created.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
        </xs:sequence>
      </xs:complexType>

      <xs:simpleType name="certificateIdType">
        <xs:restriction base="xs:string">
          <xs:pattern value="[\w]*"/>
          <xs:minLength value="24"/>
          <xs:maxLength value="128"/>
        </xs:restriction>
      </xs:simpleType>

      <xs:simpleType name="pathType">
        <xs:restriction base="xs:string">
          <xs:pattern value="(\u002F)|(\u002F[\u0021-\u007F]+\u002F)"/>
          <xs:minLength value="1"/>
          <xs:maxLength value="512"/>
        </xs:restriction>
      </xs:simpleType>

      <xs:simpleType name="arnType">
        <xs:restriction base="xs:string">
          <xs:minLength value="20"/>
          <xs:maxLength value="2048"/>
        </xs:restriction>
      </xs:simpleType>

      <xs:simpleType name="idType">
        <xs:restriction base="xs:string">
          <xs:pattern value="[\w]*"/>
          <xs:minLength value="16"/>
          <xs:maxLength value="32"/>
        </xs:restriction>
      </xs:simpleType>

      <xs:complexType name="certificateListType">

        <xs:annotation>
          <xs:documentation><![CDATA[
            <p>The certificateListType data type contains a list of signing certificates.</p>
            
            <p>
            This data type is used as a response element in the action <a>ListSigningCertificates</a>.
            </p>
          ]]></xs:documentation>
        </xs:annotation>
        
        <xs:sequence>
          <xs:element name="member" type="tns:SigningCertificate" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:complexType>

      <xs:complexType name="accessKeyMetadataListType">

        <xs:annotation>
          <xs:documentation><![CDATA[
            <p>The accessKeyMetadataListType data type contains a list of access key metadata.</p>
            
            <p>
            This data type is used as a response element in the action <a>ListAccessKeys</a>.
            </p>
          ]]></xs:documentation>
        </xs:annotation>
        
        <xs:sequence>
          <xs:element name="member" type="tns:AccessKeyMetadata" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:complexType>

      <xs:simpleType name="authenticationCodeType">
        <xs:restriction base="xs:string">
          <xs:pattern value="[\d]*"/>
          <xs:minLength value="6"/>
          <xs:maxLength value="6"/>
        </xs:restriction>
      </xs:simpleType>

      <xs:complexType name="MFADevice">

        <xs:annotation>
          <xs:documentation><![CDATA[
            <p>The <code>MFADevice</code> data type contains information about an MFA device.</p>
            
        	<p>
            This data type is used as a response element in the action <a>ListMFADevices</a>.
        
            </p>
          ]]></xs:documentation>
        </xs:annotation>
        
        <xs:sequence>
            <xs:element name="UserName" type="tns:userNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The user with whom the MFA device is associated.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="SerialNumber" type="tns:serialNumberType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The serial number that uniquely identifies the MFA device. For virtual MFA devices, the serial number is the device ARN.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="EnableDate" type="xs:dateTime">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The date when the MFA device was enabled for the user.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
        </xs:sequence>
      </xs:complexType>

      <xs:simpleType name="existingUserNameType">
        <xs:restriction base="xs:string">
          <xs:pattern value="[\w+=,.@-]*"/>
          <xs:minLength value="1"/>
          <xs:maxLength value="128"/>
        </xs:restriction>
      </xs:simpleType>

      <xs:simpleType name="privateKeyType">
        <xs:restriction base="xs:string">
          <xs:pattern value="[\u0009\u000A\u000D\u0020-\u00FF]*"/>
          <xs:minLength value="1"/>
          <xs:maxLength value="16384"/>
        </xs:restriction>
      </xs:simpleType>

      <xs:complexType name="policyNameListType">

        <xs:annotation>
          <xs:documentation><![CDATA[
            <p>The policyNameListType data type contains a list of policy names.</p>
        
            <p>
            This data type is used as a response element in the action <a>ListPolicies</a>.
            </p>
          ]]></xs:documentation>
        </xs:annotation>
        
        <xs:sequence>
          <xs:element name="member" type="tns:policyNameType" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:complexType>

      <xs:simpleType name="serialNumberType">
        <xs:restriction base="xs:string">
          <xs:pattern value="[\w+=/:,.@-]*"/>
          <xs:minLength value="9"/>
          <xs:maxLength value="256"/>
        </xs:restriction>
      </xs:simpleType>

      <xs:simpleType name="accessKeyIdType">
        <xs:restriction base="xs:string">
          <xs:pattern value="[\w]*"/>
          <xs:minLength value="16"/>
          <xs:maxLength value="32"/>
        </xs:restriction>
      </xs:simpleType>

      <xs:simpleType name="summaryKeyType">
        <xs:restriction base="xs:string">
          <xs:enumeration value="Users"/>
          <xs:enumeration value="UsersQuota"/>
          <xs:enumeration value="Groups"/>
          <xs:enumeration value="GroupsQuota"/>
          <xs:enumeration value="ServerCertificates"/>
          <xs:enumeration value="ServerCertificatesQuota"/>
          <xs:enumeration value="UserPolicySizeQuota"/>
          <xs:enumeration value="GroupPolicySizeQuota"/>
          <xs:enumeration value="GroupsPerUserQuota"/>
          <xs:enumeration value="SigningCertificatesPerUserQuota"/>
          <xs:enumeration value="AccessKeysPerUserQuota"/>
          <xs:enumeration value="MFADevices"/>
          <xs:enumeration value="MFADevicesInUse"/>
          <xs:enumeration value="AccountMFAEnabled"/>
        </xs:restriction>
      </xs:simpleType>

      <xs:complexType name="LoginProfile">

        <xs:annotation>
          <xs:documentation><![CDATA[
            <p>The LoginProfile data type contains the user name and password create date for a user.</p>
            
        	<p>
            This data type is used as a response element in the actions <a>CreateLoginProfile</a> and <a>GetLoginProfile</a>.
        	</p>
          ]]></xs:documentation>
        </xs:annotation>
        
        <xs:sequence>
            <xs:element name="UserName" type="tns:userNameType">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The name of the user, which can be used for signing into the AWS Management Console.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
            <xs:element name="CreateDate" type="xs:dateTime">

              <xs:annotation>
                <xs:documentation><![CDATA[
                  <p>The date when the password for the user was created.</p>
                ]]></xs:documentation>
              </xs:annotation>
              
            </xs:element>
        </xs:sequence>
      </xs:complexType>

    </xs:schema>

  </wsdl:types>

  <wsdl:message name="DeleteAccountAliasRequestMsg">
    <wsdl:part element="tns:DeleteAccountAlias" name="body"/>
  </wsdl:message>

  <wsdl:message name="DeleteAccountAliasResponseMsg">
    <wsdl:part element="tns:DeleteAccountAliasResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="ListGroupsRequestMsg">
    <wsdl:part element="tns:ListGroups" name="body"/>
  </wsdl:message>

  <wsdl:message name="ListGroupsResponseMsg">
    <wsdl:part element="tns:ListGroupsResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="DeleteAccessKeyRequestMsg">
    <wsdl:part element="tns:DeleteAccessKey" name="body"/>
  </wsdl:message>

  <wsdl:message name="DeleteAccessKeyResponseMsg">
    <wsdl:part element="tns:DeleteAccessKeyResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="DeleteVirtualMFADeviceRequestMsg">
    <wsdl:part element="tns:DeleteVirtualMFADevice" name="body"/>
  </wsdl:message>

  <wsdl:message name="DeleteVirtualMFADeviceResponseMsg">
    <wsdl:part element="tns:DeleteVirtualMFADeviceResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="DeleteUserPolicyRequestMsg">
    <wsdl:part element="tns:DeleteUserPolicy" name="body"/>
  </wsdl:message>

  <wsdl:message name="DeleteUserPolicyResponseMsg">
    <wsdl:part element="tns:DeleteUserPolicyResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="PutUserPolicyRequestMsg">
    <wsdl:part element="tns:PutUserPolicy" name="body"/>
  </wsdl:message>

  <wsdl:message name="PutUserPolicyResponseMsg">
    <wsdl:part element="tns:PutUserPolicyResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="ListServerCertificatesRequestMsg">
    <wsdl:part element="tns:ListServerCertificates" name="body"/>
  </wsdl:message>

  <wsdl:message name="ListServerCertificatesResponseMsg">
    <wsdl:part element="tns:ListServerCertificatesResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="GetUserPolicyRequestMsg">
    <wsdl:part element="tns:GetUserPolicy" name="body"/>
  </wsdl:message>

  <wsdl:message name="GetUserPolicyResponseMsg">
    <wsdl:part element="tns:GetUserPolicyResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="UpdateServerCertificateRequestMsg">
    <wsdl:part element="tns:UpdateServerCertificate" name="body"/>
  </wsdl:message>

  <wsdl:message name="UpdateServerCertificateResponseMsg">
    <wsdl:part element="tns:UpdateServerCertificateResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="UpdateUserRequestMsg">
    <wsdl:part element="tns:UpdateUser" name="body"/>
  </wsdl:message>

  <wsdl:message name="UpdateUserResponseMsg">
    <wsdl:part element="tns:UpdateUserResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="PutRolePolicyRequestMsg">
    <wsdl:part element="tns:PutRolePolicy" name="body"/>
  </wsdl:message>

  <wsdl:message name="PutRolePolicyResponseMsg">
    <wsdl:part element="tns:PutRolePolicyResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="UpdateSigningCertificateRequestMsg">
    <wsdl:part element="tns:UpdateSigningCertificate" name="body"/>
  </wsdl:message>

  <wsdl:message name="UpdateSigningCertificateResponseMsg">
    <wsdl:part element="tns:UpdateSigningCertificateResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="DeleteGroupPolicyRequestMsg">
    <wsdl:part element="tns:DeleteGroupPolicy" name="body"/>
  </wsdl:message>

  <wsdl:message name="DeleteGroupPolicyResponseMsg">
    <wsdl:part element="tns:DeleteGroupPolicyResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="ListUsersRequestMsg">
    <wsdl:part element="tns:ListUsers" name="body"/>
  </wsdl:message>

  <wsdl:message name="ListUsersResponseMsg">
    <wsdl:part element="tns:ListUsersResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="UpdateGroupRequestMsg">
    <wsdl:part element="tns:UpdateGroup" name="body"/>
  </wsdl:message>

  <wsdl:message name="UpdateGroupResponseMsg">
    <wsdl:part element="tns:UpdateGroupResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="CreateUserRequestMsg">
    <wsdl:part element="tns:CreateUser" name="body"/>
  </wsdl:message>

  <wsdl:message name="CreateUserResponseMsg">
    <wsdl:part element="tns:CreateUserResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="EnableMFADeviceRequestMsg">
    <wsdl:part element="tns:EnableMFADevice" name="body"/>
  </wsdl:message>

  <wsdl:message name="EnableMFADeviceResponseMsg">
    <wsdl:part element="tns:EnableMFADeviceResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="DeleteAccountPasswordPolicyRequestMsg">
    <wsdl:part element="tns:DeleteAccountPasswordPolicy" name="body"/>
  </wsdl:message>

  <wsdl:message name="DeleteAccountPasswordPolicyResponseMsg">
    <wsdl:part element="tns:DeleteAccountPasswordPolicyResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="GetLoginProfileRequestMsg">
    <wsdl:part element="tns:GetLoginProfile" name="body"/>
  </wsdl:message>

  <wsdl:message name="GetLoginProfileResponseMsg">
    <wsdl:part element="tns:GetLoginProfileResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="UploadServerCertificateRequestMsg">
    <wsdl:part element="tns:UploadServerCertificate" name="body"/>
  </wsdl:message>

  <wsdl:message name="UploadServerCertificateResponseMsg">
    <wsdl:part element="tns:UploadServerCertificateResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="CreateGroupRequestMsg">
    <wsdl:part element="tns:CreateGroup" name="body"/>
  </wsdl:message>

  <wsdl:message name="CreateGroupResponseMsg">
    <wsdl:part element="tns:CreateGroupResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="CreateAccountAliasRequestMsg">
    <wsdl:part element="tns:CreateAccountAlias" name="body"/>
  </wsdl:message>

  <wsdl:message name="CreateAccountAliasResponseMsg">
    <wsdl:part element="tns:CreateAccountAliasResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="DeleteUserRequestMsg">
    <wsdl:part element="tns:DeleteUser" name="body"/>
  </wsdl:message>

  <wsdl:message name="DeleteUserResponseMsg">
    <wsdl:part element="tns:DeleteUserResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="DeactivateMFADeviceRequestMsg">
    <wsdl:part element="tns:DeactivateMFADevice" name="body"/>
  </wsdl:message>

  <wsdl:message name="DeactivateMFADeviceResponseMsg">
    <wsdl:part element="tns:DeactivateMFADeviceResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="RemoveUserFromGroupRequestMsg">
    <wsdl:part element="tns:RemoveUserFromGroup" name="body"/>
  </wsdl:message>

  <wsdl:message name="RemoveUserFromGroupResponseMsg">
    <wsdl:part element="tns:RemoveUserFromGroupResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="DeleteRoleRequestMsg">
    <wsdl:part element="tns:DeleteRole" name="body"/>
  </wsdl:message>

  <wsdl:message name="DeleteRoleResponseMsg">
    <wsdl:part element="tns:DeleteRoleResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="DeleteServerCertificateRequestMsg">
    <wsdl:part element="tns:DeleteServerCertificate" name="body"/>
  </wsdl:message>

  <wsdl:message name="DeleteServerCertificateResponseMsg">
    <wsdl:part element="tns:DeleteServerCertificateResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="CreateAccessKeyRequestMsg">
    <wsdl:part element="tns:CreateAccessKey" name="body"/>
  </wsdl:message>

  <wsdl:message name="CreateAccessKeyResponseMsg">
    <wsdl:part element="tns:CreateAccessKeyResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="GetUserRequestMsg">
    <wsdl:part element="tns:GetUser" name="body"/>
  </wsdl:message>

  <wsdl:message name="GetUserResponseMsg">
    <wsdl:part element="tns:GetUserResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="ResyncMFADeviceRequestMsg">
    <wsdl:part element="tns:ResyncMFADevice" name="body"/>
  </wsdl:message>

  <wsdl:message name="ResyncMFADeviceResponseMsg">
    <wsdl:part element="tns:ResyncMFADeviceResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="ListMFADevicesRequestMsg">
    <wsdl:part element="tns:ListMFADevices" name="body"/>
  </wsdl:message>

  <wsdl:message name="ListMFADevicesResponseMsg">
    <wsdl:part element="tns:ListMFADevicesResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="CreateVirtualMFADeviceRequestMsg">
    <wsdl:part element="tns:CreateVirtualMFADevice" name="body"/>
  </wsdl:message>

  <wsdl:message name="CreateVirtualMFADeviceResponseMsg">
    <wsdl:part element="tns:CreateVirtualMFADeviceResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="ListInstanceProfilesRequestMsg">
    <wsdl:part element="tns:ListInstanceProfiles" name="body"/>
  </wsdl:message>

  <wsdl:message name="ListInstanceProfilesResponseMsg">
    <wsdl:part element="tns:ListInstanceProfilesResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="UpdateAccessKeyRequestMsg">
    <wsdl:part element="tns:UpdateAccessKey" name="body"/>
  </wsdl:message>

  <wsdl:message name="UpdateAccessKeyResponseMsg">
    <wsdl:part element="tns:UpdateAccessKeyResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="AddUserToGroupRequestMsg">
    <wsdl:part element="tns:AddUserToGroup" name="body"/>
  </wsdl:message>

  <wsdl:message name="AddUserToGroupResponseMsg">
    <wsdl:part element="tns:AddUserToGroupResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="GetGroupRequestMsg">
    <wsdl:part element="tns:GetGroup" name="body"/>
  </wsdl:message>

  <wsdl:message name="GetGroupResponseMsg">
    <wsdl:part element="tns:GetGroupResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="ListAccountAliasesRequestMsg">
    <wsdl:part element="tns:ListAccountAliases" name="body"/>
  </wsdl:message>

  <wsdl:message name="ListAccountAliasesResponseMsg">
    <wsdl:part element="tns:ListAccountAliasesResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="DeleteGroupRequestMsg">
    <wsdl:part element="tns:DeleteGroup" name="body"/>
  </wsdl:message>

  <wsdl:message name="DeleteGroupResponseMsg">
    <wsdl:part element="tns:DeleteGroupResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="GetRoleRequestMsg">
    <wsdl:part element="tns:GetRole" name="body"/>
  </wsdl:message>

  <wsdl:message name="GetRoleResponseMsg">
    <wsdl:part element="tns:GetRoleResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="ListRolePoliciesRequestMsg">
    <wsdl:part element="tns:ListRolePolicies" name="body"/>
  </wsdl:message>

  <wsdl:message name="ListRolePoliciesResponseMsg">
    <wsdl:part element="tns:ListRolePoliciesResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="ListSigningCertificatesRequestMsg">
    <wsdl:part element="tns:ListSigningCertificates" name="body"/>
  </wsdl:message>

  <wsdl:message name="ListSigningCertificatesResponseMsg">
    <wsdl:part element="tns:ListSigningCertificatesResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="UploadSigningCertificateRequestMsg">
    <wsdl:part element="tns:UploadSigningCertificate" name="body"/>
  </wsdl:message>

  <wsdl:message name="UploadSigningCertificateResponseMsg">
    <wsdl:part element="tns:UploadSigningCertificateResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="DeleteInstanceProfileRequestMsg">
    <wsdl:part element="tns:DeleteInstanceProfile" name="body"/>
  </wsdl:message>

  <wsdl:message name="DeleteInstanceProfileResponseMsg">
    <wsdl:part element="tns:DeleteInstanceProfileResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="CreateRoleRequestMsg">
    <wsdl:part element="tns:CreateRole" name="body"/>
  </wsdl:message>

  <wsdl:message name="CreateRoleResponseMsg">
    <wsdl:part element="tns:CreateRoleResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="UpdateLoginProfileRequestMsg">
    <wsdl:part element="tns:UpdateLoginProfile" name="body"/>
  </wsdl:message>

  <wsdl:message name="UpdateLoginProfileResponseMsg">
    <wsdl:part element="tns:UpdateLoginProfileResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="DeleteLoginProfileRequestMsg">
    <wsdl:part element="tns:DeleteLoginProfile" name="body"/>
  </wsdl:message>

  <wsdl:message name="DeleteLoginProfileResponseMsg">
    <wsdl:part element="tns:DeleteLoginProfileResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="ChangePasswordRequestMsg">
    <wsdl:part element="tns:ChangePassword" name="body"/>
  </wsdl:message>

  <wsdl:message name="ChangePasswordResponseMsg">
    <wsdl:part element="tns:ChangePasswordResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="GetServerCertificateRequestMsg">
    <wsdl:part element="tns:GetServerCertificate" name="body"/>
  </wsdl:message>

  <wsdl:message name="GetServerCertificateResponseMsg">
    <wsdl:part element="tns:GetServerCertificateResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="PutGroupPolicyRequestMsg">
    <wsdl:part element="tns:PutGroupPolicy" name="body"/>
  </wsdl:message>

  <wsdl:message name="PutGroupPolicyResponseMsg">
    <wsdl:part element="tns:PutGroupPolicyResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="DeleteSigningCertificateRequestMsg">
    <wsdl:part element="tns:DeleteSigningCertificate" name="body"/>
  </wsdl:message>

  <wsdl:message name="DeleteSigningCertificateResponseMsg">
    <wsdl:part element="tns:DeleteSigningCertificateResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="ListUserPoliciesRequestMsg">
    <wsdl:part element="tns:ListUserPolicies" name="body"/>
  </wsdl:message>

  <wsdl:message name="ListUserPoliciesResponseMsg">
    <wsdl:part element="tns:ListUserPoliciesResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="ListAccessKeysRequestMsg">
    <wsdl:part element="tns:ListAccessKeys" name="body"/>
  </wsdl:message>

  <wsdl:message name="ListAccessKeysResponseMsg">
    <wsdl:part element="tns:ListAccessKeysResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="ListGroupsForUserRequestMsg">
    <wsdl:part element="tns:ListGroupsForUser" name="body"/>
  </wsdl:message>

  <wsdl:message name="ListGroupsForUserResponseMsg">
    <wsdl:part element="tns:ListGroupsForUserResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="AddRoleToInstanceProfileRequestMsg">
    <wsdl:part element="tns:AddRoleToInstanceProfile" name="body"/>
  </wsdl:message>

  <wsdl:message name="AddRoleToInstanceProfileResponseMsg">
    <wsdl:part element="tns:AddRoleToInstanceProfileResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="GetGroupPolicyRequestMsg">
    <wsdl:part element="tns:GetGroupPolicy" name="body"/>
  </wsdl:message>

  <wsdl:message name="GetGroupPolicyResponseMsg">
    <wsdl:part element="tns:GetGroupPolicyResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="GetRolePolicyRequestMsg">
    <wsdl:part element="tns:GetRolePolicy" name="body"/>
  </wsdl:message>

  <wsdl:message name="GetRolePolicyResponseMsg">
    <wsdl:part element="tns:GetRolePolicyResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="ListInstanceProfilesForRoleRequestMsg">
    <wsdl:part element="tns:ListInstanceProfilesForRole" name="body"/>
  </wsdl:message>

  <wsdl:message name="ListInstanceProfilesForRoleResponseMsg">
    <wsdl:part element="tns:ListInstanceProfilesForRoleResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="ListVirtualMFADevicesRequestMsg">
    <wsdl:part element="tns:ListVirtualMFADevices" name="body"/>
  </wsdl:message>

  <wsdl:message name="ListVirtualMFADevicesResponseMsg">
    <wsdl:part element="tns:ListVirtualMFADevicesResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="DeleteRolePolicyRequestMsg">
    <wsdl:part element="tns:DeleteRolePolicy" name="body"/>
  </wsdl:message>

  <wsdl:message name="DeleteRolePolicyResponseMsg">
    <wsdl:part element="tns:DeleteRolePolicyResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="CreateInstanceProfileRequestMsg">
    <wsdl:part element="tns:CreateInstanceProfile" name="body"/>
  </wsdl:message>

  <wsdl:message name="CreateInstanceProfileResponseMsg">
    <wsdl:part element="tns:CreateInstanceProfileResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="ListGroupPoliciesRequestMsg">
    <wsdl:part element="tns:ListGroupPolicies" name="body"/>
  </wsdl:message>

  <wsdl:message name="ListGroupPoliciesResponseMsg">
    <wsdl:part element="tns:ListGroupPoliciesResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="CreateLoginProfileRequestMsg">
    <wsdl:part element="tns:CreateLoginProfile" name="body"/>
  </wsdl:message>

  <wsdl:message name="CreateLoginProfileResponseMsg">
    <wsdl:part element="tns:CreateLoginProfileResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="RemoveRoleFromInstanceProfileRequestMsg">
    <wsdl:part element="tns:RemoveRoleFromInstanceProfile" name="body"/>
  </wsdl:message>

  <wsdl:message name="RemoveRoleFromInstanceProfileResponseMsg">
    <wsdl:part element="tns:RemoveRoleFromInstanceProfileResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="UpdateAccountPasswordPolicyRequestMsg">
    <wsdl:part element="tns:UpdateAccountPasswordPolicy" name="body"/>
  </wsdl:message>

  <wsdl:message name="UpdateAccountPasswordPolicyResponseMsg">
    <wsdl:part element="tns:UpdateAccountPasswordPolicyResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="UpdateAssumeRolePolicyRequestMsg">
    <wsdl:part element="tns:UpdateAssumeRolePolicy" name="body"/>
  </wsdl:message>

  <wsdl:message name="UpdateAssumeRolePolicyResponseMsg">
    <wsdl:part element="tns:UpdateAssumeRolePolicyResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="GetInstanceProfileRequestMsg">
    <wsdl:part element="tns:GetInstanceProfile" name="body"/>
  </wsdl:message>

  <wsdl:message name="GetInstanceProfileResponseMsg">
    <wsdl:part element="tns:GetInstanceProfileResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="ListRolesRequestMsg">
    <wsdl:part element="tns:ListRoles" name="body"/>
  </wsdl:message>

  <wsdl:message name="ListRolesResponseMsg">
    <wsdl:part element="tns:ListRolesResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="GetAccountSummaryRequestMsg">
    <wsdl:part element="tns:GetAccountSummary" name="body"/>
  </wsdl:message>

  <wsdl:message name="GetAccountSummaryResponseMsg">
    <wsdl:part element="tns:GetAccountSummaryResponse" name="body"/>
  </wsdl:message>

  <wsdl:message name="GetAccountPasswordPolicyRequestMsg">
    <wsdl:part element="tns:GetAccountPasswordPolicy" name="body"/>
  </wsdl:message>

  <wsdl:message name="GetAccountPasswordPolicyResponseMsg">
    <wsdl:part element="tns:GetAccountPasswordPolicyResponse" name="body"/>
  </wsdl:message>

  <wsdl:portType name="AWSIdentityManagementV20100508PortType">

    <wsdl:operation name="DeleteAccountAlias">
      <wsdl:documentation><![CDATA[
    <p>Deletes the specified AWS account alias. For information about using an AWS account 
    alias, see <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/AccountAlias.html" target="_blank">Using an Alias for Your AWS Account ID</a> in <i>Using AWS Identity and Access Management</i>.</p>

    <examples>
      <queryrequest>
https://iam.amazonaws.com/
?Action=DeleteAccountAlias
&AccountAlias=foocorporation
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<DeleteAccountAliasResponse>
  <ResponseMetadata>
    <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
  </ResponseMetadata>
</DeleteAccountAliasResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:DeleteAccountAliasRequestMsg" wsa:Action="urn:DeleteAccountAlias"/>
      <wsdl:output message="tns:DeleteAccountAliasResponseMsg" wsa:Action="urn:DeleteAccountAlias:Response"/>
    </wsdl:operation>

    <wsdl:operation name="ListGroups">
      <wsdl:documentation><![CDATA[
    <p>Lists the groups that have the specified path prefix.</p>
     
    <p>You can paginate the results using the <code>MaxItems</code> and <code>Marker</code> parameters.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=ListGroups
&PathPrefix=/division_abc/subdivision_xyz/
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<ListGroupsResponse>
   <ListGroupsResult>
      <Groups>
         <member>
            <Path>/division_abc/subdivision_xyz/</Path>
            <GroupName>Admins</GroupName>
            <GroupId>AGPACKCEVSQ6C2EXAMPLE</GroupId>
            <Arn>arn:aws:iam::123456789012:group/Admins</Arn>
         </member>
         <member>
            <Path>/division_abc/subdivision_xyz/product_1234/engineering/
            </Path>
            <GroupName>Test</GroupName>
            <GroupId>AGP2MAB8DPLSRHEXAMPLE</GroupId>
            <Arn>arn:aws:iam::123456789012:group
            /division_abc/subdivision_xyz/product_1234/engineering/Test</Arn>
         </member>
         <member>
            <Path>/division_abc/subdivision_xyz/product_1234/</Path>
            <GroupName>Managers</GroupName>
            <GroupId>AGPIODR4TAW7CSEXAMPLE</GroupId>
            <Arn>arn:aws:iam::123456789012
            :group/division_abc/subdivision_xyz/product_1234/Managers</Arn>
         </member>
      </Groups>
      <IsTruncated>false</IsTruncated>
   </ListGroupsResult>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</ListGroupsResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:ListGroupsRequestMsg" wsa:Action="urn:ListGroups"/>
      <wsdl:output message="tns:ListGroupsResponseMsg" wsa:Action="urn:ListGroups:Response"/>
    </wsdl:operation>

    <wsdl:operation name="DeleteAccessKey">
      <wsdl:documentation><![CDATA[
    <p>Deletes the access key associated with the specified user.</p>

<p>If you do not specify a user name, IAM determines the user name implicitly based on the AWS
    Access Key ID signing the request. Because this action works for access keys under the AWS account,
    you can use this API to manage root credentials even if the AWS account has no associated users.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=DeleteAccessKey
&UserName=Bob
&AccessKeyId=AKIAIOSFODNN7EXAMPLE
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<DeleteAccessKeyResponse>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</DeleteAccessKeyResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:DeleteAccessKeyRequestMsg" wsa:Action="urn:DeleteAccessKey"/>
      <wsdl:output message="tns:DeleteAccessKeyResponseMsg" wsa:Action="urn:DeleteAccessKey:Response"/>
    </wsdl:operation>

    <wsdl:operation name="DeleteVirtualMFADevice">
      <wsdl:documentation><![CDATA[
    <p>Deletes a virtual MFA device.</p>

    <note>You must deactivate a user's virtual MFA device before you can delete it. For information about 
      deactivating MFA devices, see <a href="http://docs.amazonwebservices.com/IAM/latest/APIReference/API_DeactivateMFADevice.html">DeactivateMFADevice</a>.</note>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=DeleteVirtualMFADevice
&SerialNumber=arn:aws:iam::123456789012:mfa/ExampleName
&Version=2010-05-08
&AUTHPARAMS
</queryrequest>

      <queryresponse>
<DeleteVirtualMFADeviceResponse>
  <DeleteVirtualMFADeviceResult>
    <VirtualMFADevice>
      <SerialNumber>arn:aws:iam::123456789012:mfa/ExampleName</SerialNumber>
    </VirtualMFADevice>
  </DeleteVirtualMFADeviceResult>
  <ResponseMetadata>
    <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
  </ResponseMetadata>
</DeleteVirtualMFADeviceResponse>
</queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:DeleteVirtualMFADeviceRequestMsg" wsa:Action="urn:DeleteVirtualMFADevice"/>
      <wsdl:output message="tns:DeleteVirtualMFADeviceResponseMsg" wsa:Action="urn:DeleteVirtualMFADevice:Response"/>
    </wsdl:operation>

    <wsdl:operation name="DeleteUserPolicy">
      <wsdl:documentation><![CDATA[
    <p>Deletes the specified policy associated with the specified user.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=DeleteUserPolicy
&UserName=Bob
&PolicyName=AllAccessPolicy
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<DeleteUserPolicyResponse>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</DeleteUserPolicyResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:DeleteUserPolicyRequestMsg" wsa:Action="urn:DeleteUserPolicy"/>
      <wsdl:output message="tns:DeleteUserPolicyResponseMsg" wsa:Action="urn:DeleteUserPolicy:Response"/>
    </wsdl:operation>

    <wsdl:operation name="PutUserPolicy">
      <wsdl:documentation><![CDATA[
    <p>Adds (or updates) a policy document associated with the specified user. For information about
    policies, refer to <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?PoliciesOverview.html" target="_blank">Overview of Policies</a> in <i>Using AWS Identity and Access Management</i>.</p>

    <p>For information about limits on the number of policies you can associate with a user, see
     <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?LimitationsOnEntities.html" target="_blank">Limitations on IAM Entities</a> in <i>Using AWS Identity and Access Management</i>.</p>

    <note>Because policy documents can be large, you should use POST rather than GET when
    	calling <code>PutUserPolicy</code>. For information about setting up signatures and 
    	authorization through the API, go to <a href="http://docs.amazonwebservices.com/general/latest/gr/signing_aws_api_requests.html" target="_blank">Signing AWS API Requests</a> in the <i>AWS General Reference</i>. For general information about 
    	using the Query API with IAM, go to <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/IAM_UsingQueryAPI.html" target="_blank">Making Query Requests</a> in <i>Using IAM</i>.</note>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=PutUserPolicy
&UserName=Bob
&PolicyName=AllAccessPolicy
&PolicyDocument={"Statement":[{"Effect":"Allow","Action":"*","Resource":"*"}]}
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<PutUserPolicyResponse>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</PutUserPolicyResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:PutUserPolicyRequestMsg" wsa:Action="urn:PutUserPolicy"/>
      <wsdl:output message="tns:PutUserPolicyResponseMsg" wsa:Action="urn:PutUserPolicy:Response"/>
    </wsdl:operation>

    <wsdl:operation name="ListServerCertificates">
      <wsdl:documentation><![CDATA[
    <p>Lists the server certificates that have the specified path prefix. If none exist, the
    action returns an empty list.</p>

    <p>You can paginate the results using the <code>MaxItems</code> and <code>Marker</code> parameters.</p>

    <examples>
      <queryrequest>
https://iam.amazonaws.com/
?Action=ListServerCertificates
&PathPrefix=/company/servercerts
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<ListServerCertificatesResponse>
  <ListServerCertificatesResult>
    <IsTruncated>false</IsTruncated>
    <ServerCertificateMetadataList>
      <member>
        <ServerCertificateMetadata>
          <ServerCertificateName>ProdServerCert</ServerCertificateName>
          <Path>/company/servercerts/</Path>
          <Arn>arn:aws:iam::123456789012:server-certificate/company/servercerts/ProdServerCert</Arn>
          <UploadDate>2010-05-08T01:02:03.004Z</UploadDate>
          <ServerCertificateId>ASCACKCEVSQ6CEXAMPLE1</ServerCertificateId>
        </ServerCertificateMetadata>
      </member>
      <member>
        <ServerCertificateMetadata>
          <ServerCertificateName>BetaServerCert</ServerCertificateName>
          <Path>/company/servercerts/</Path>
          <Arn>arn:aws:iam::123456789012:server-certificate/company/servercerts/BetaServerCert</Arn>
          <UploadDate>2010-05-08T02:03:01.004Z</UploadDate>
          <ServerCertificateId>ASCACKCEVSQ6CEXAMPLE2</ServerCertificateId>
        </ServerCertificateMetadata>
      </member>
      <member>
        <ServerCertificateMetadata>
          <ServerCertificateName>TestServerCert</ServerCertificateName>
          <Path>/company/servercerts/</Path>
          <Arn>arn:aws:iam::123456789012:server-certificate/company/servercerts/TestServerCert</Arn>
          <UploadDate>2010-05-08T03:01:02.004Z</UploadDate>
          <ServerCertificateId>ASCACKCEVSQ6CEXAMPLE3</ServerCertificateId>
        </ServerCertificateMetadata>
      </member>
    </ServerCertificateMetadataList>
  </ListServerCertificatesResult>
  <ResponseMetadata>
    <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
  </ResponseMetadata>
</ListServerCertificatesResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:ListServerCertificatesRequestMsg" wsa:Action="urn:ListServerCertificates"/>
      <wsdl:output message="tns:ListServerCertificatesResponseMsg" wsa:Action="urn:ListServerCertificates:Response"/>
    </wsdl:operation>

    <wsdl:operation name="GetUserPolicy">
      <wsdl:documentation><![CDATA[
    <p>Retrieves the specified policy document for the specified user. The returned policy is URL-encoded
    according to RFC 3986. For more information about RFC 3986, go to <a href="http://www.faqs.org/rfcs/rfc3986.html">http://www.faqs.org/rfcs/rfc3986.html</a>.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=GetUserPolicy
&UserName=Bob
&PolicyName=AllAccessPolicy
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<GetUserPolicyResponse>
   <GetUserPolicyResult>
      <UserName>Bob</UserName>
      <PolicyName>AllAccessPolicy</PolicyName>
      <PolicyDocument>
      {"Statement":[{"Effect":"Allow","Action":"*","Resource":"*"}]}
      </PolicyDocument>
   </GetUserPolicyResult>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</GetUserPolicyResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:GetUserPolicyRequestMsg" wsa:Action="urn:GetUserPolicy"/>
      <wsdl:output message="tns:GetUserPolicyResponseMsg" wsa:Action="urn:GetUserPolicy:Response"/>
    </wsdl:operation>

    <wsdl:operation name="UpdateServerCertificate">
      <wsdl:documentation><![CDATA[
    <p>Updates the name and/or the path of the specified server certificate.</p>

    <important>
    You should understand the implications of changing a server certificate's path or name. For more
    information, see <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/ManagingServerCerts.html" target="_blank">Managing Server Certificates</a> in <i>Using AWS Identity and Access Management</i>.
    </important>

    <note>To change a server certificate name the requester must have appropriate permissions on both
    the source object and the target object.  For example, to change the name from ProductionCert to
    ProdCert, the entity making the request must have permission on ProductionCert and ProdCert, or
    must have permission on all (*). For more information about permissions,
    see <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/PermissionsAndPolicies.html" target="blank">Permissions and Policies</a>.
    </note>

    <examples>
      <queryrequest>
https://iam.amazonaws.com/
?Action=UpdateServerCertificate
&ServerCertificateName=ProdServerCert
&NewServerCertificateName=ProdServerCertName
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<UpdateServerCertificateResponse>
  <ResponseMetadata>
    <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
  </ResponseMetadata>
</UpdateServerCertificateResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:UpdateServerCertificateRequestMsg" wsa:Action="urn:UpdateServerCertificate"/>
      <wsdl:output message="tns:UpdateServerCertificateResponseMsg" wsa:Action="urn:UpdateServerCertificate:Response"/>
    </wsdl:operation>

    <wsdl:operation name="UpdateUser">
      <wsdl:documentation><![CDATA[
    <p>Updates the name and/or the path of the specified user.</p>
    
    <important>
    You should understand the implications of changing a user's path or name. For more information,
    see <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?Using_Renaming.html" target="_blank">Renaming
     Users and Groups</a> in <i>Using AWS Identity and Access Management</i>.
    </important>

	<note>To change a user name the requester must have appropriate permissions on both the source object and
	the target object.  For example, to change Bob to Robert, the entity making the request must have permission
	on Bob and Robert, or must have permission on all (*).  For more information about permissions, see <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/PermissionsAndPolicies.html" target="blank">Permissions and Policies</a>.
	</note>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=UpdateUser
&UserName=Bob
&NewUserName=Robert
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<UpdateUserResponse>
   <UpdateUserResult>
   <User>
      <Path>/division_abc/subdivision_xyz/</Path>
      <UserName>Robert</UserName>
      <UserId>AIDACKCEVSQ6C2EXAMPLE</UserId>
      <Arn>arn:aws::123456789012:user/division_abc/subdivision_xyz/Robert
      </Arn>
   </User>
   </UpdateUserResult>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</UpdateUserResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:UpdateUserRequestMsg" wsa:Action="urn:UpdateUser"/>
      <wsdl:output message="tns:UpdateUserResponseMsg" wsa:Action="urn:UpdateUser:Response"/>
    </wsdl:operation>

    <wsdl:operation name="PutRolePolicy">
      <wsdl:documentation><![CDATA[
    <p>Adds (or updates) a policy document associated with the specified role. For information about
    policies, refer to <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?PoliciesOverview.html" target="_blank">Overview of Policies</a> in <i>Using AWS Identity and Access Management</i>.</p>

    <p>For information about limits on the number of policies you can associate with a role, see
     <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?LimitationsOnEntities.html" target="_blank">Limitations on IAM Entities</a> in <i>Using AWS Identity and Access Management</i>.</p>

    <note>Because policy documents can be large, you should use POST rather than GET when
    	calling <code>PutRolePolicy</code>. For information about setting up signatures and 
    	authorization through the API, go to <a href="http://docs.amazonwebservices.com/general/latest/gr/signing_aws_api_requests.html" target="_blank">Signing AWS API Requests</a> in the <i>AWS General Reference</i>. For general information about 
    	using the Query API with IAM, go to <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/IAM_UsingQueryAPI.html" target="_blank">Making Query Requests</a> in <i>Using IAM</i>.</note>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=PutRolePolicy
&RoleName=S3Access
&PolicyName=S3AccessPolicy
&PolicyDocument={"Statement":[{"Effect":"Allow","Action":"s3:*","Resource":"*"}]}
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<PutRolePolicyResponse>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</PutRolePolicyResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:PutRolePolicyRequestMsg" wsa:Action="urn:PutRolePolicy"/>
      <wsdl:output message="tns:PutRolePolicyResponseMsg" wsa:Action="urn:PutRolePolicy:Response"/>
    </wsdl:operation>

    <wsdl:operation name="UpdateSigningCertificate">
      <wsdl:documentation><![CDATA[
    <p>Changes the status of the specified signing certificate from active to disabled, or vice versa.
    This action can be used to disable a user's signing certificate as part of a certificate rotation
    work flow.</p>

	<p>If the <code>UserName</code> field is not specified, the UserName is determined implicitly based
	on the AWS Access Key ID used to sign the request. Because this action works for access keys under
	the AWS account, this API can be used to manage root credentials even if the AWS account has no associated
	users.</p>


    <p>For information about rotating certificates, see <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?ManagingCredentials.html" target="_blank">Managing Keys and Certificates</a> in <i>Using AWS Identity and Access Management</i>.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=UpdateSigningCertificate
&UserName=Bob
&CertificateId=TA7SMP42TDN5Z26OBPJE7EXAMPLE
&Status=Inactive
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<UpdateSigningCertificateResponse>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</UpdateSigningCertificateResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:UpdateSigningCertificateRequestMsg" wsa:Action="urn:UpdateSigningCertificate"/>
      <wsdl:output message="tns:UpdateSigningCertificateResponseMsg" wsa:Action="urn:UpdateSigningCertificate:Response"/>
    </wsdl:operation>

    <wsdl:operation name="DeleteGroupPolicy">
      <wsdl:documentation><![CDATA[
    <p>Deletes the specified policy that is associated with the specified group.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=DeleteGroupPolicy
&GroupName=Admins
&PolicyName=AdminRoot
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<DeleteGroupPolicyResponse>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</DeleteGroupPolicyResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:DeleteGroupPolicyRequestMsg" wsa:Action="urn:DeleteGroupPolicy"/>
      <wsdl:output message="tns:DeleteGroupPolicyResponseMsg" wsa:Action="urn:DeleteGroupPolicy:Response"/>
    </wsdl:operation>

    <wsdl:operation name="ListUsers">
      <wsdl:documentation><![CDATA[
    <p>Lists the users that have the specified path prefix. If there are none, the action returns an empty list.</p>

    <p>You can paginate the results using the <code>MaxItems</code> and <code>Marker</code> parameters.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=ListUsers
&PathPrefix=/division_abc/subdivision_xyz/product_1234/engineering/
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<ListUsersResponse>
   <ListUsersResult>
      <Users>
         <member>
            <Path>/division_abc/subdivision_xyz/engineering/</Path>
            <UserName>Andrew</UserName>
            <UserId>AID2MAB8DPLSRHEXAMPLE</UserId>
            <Arn>arn:aws:iam::123456789012:user
            /division_abc/subdivision_xyz/engineering/Andrew</Arn>
         </member>
         <member>
            <Path>/division_abc/subdivision_xyz/engineering/</Path>
            <UserName>Jackie</UserName>
            <UserId>AIDIODR4TAW7CSEXAMPLE</UserId>
            <Arn>arn:aws:iam::123456789012:user
            /division_abc/subdivision_xyz/engineering/Jackie</Arn>
         </member>
      </Users>
      <IsTruncated>false</IsTruncated>
   </ListUsersResult>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</ListUsersResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:ListUsersRequestMsg" wsa:Action="urn:ListUsers"/>
      <wsdl:output message="tns:ListUsersResponseMsg" wsa:Action="urn:ListUsers:Response"/>
    </wsdl:operation>

    <wsdl:operation name="UpdateGroup">
      <wsdl:documentation><![CDATA[
    <p>Updates the name and/or the path of the specified group.</p>
    
    <important>
    You should understand the implications of changing a group's path or name. For more information,
    see <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?Using_Renaming.html" target="_blank">Renaming Users and Groups</a> in <i>Using AWS Identity and Access Management</i>.
    </important>

	<note>To change a group name the requester must have appropriate permissions on both the source object and
	the target object.  For example, to change Managers to MGRs, the entity making the request must have permission
	on Managers and MGRs, or must have permission on all (*).  For more information about permissions, see <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/PermissionsAndPolicies.html" target="blank">Permissions and Policies</a>.
	</note>




    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=UpdateGroup
&GroupName=Test
&NewGroupName=Test_1
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<UpdateGroupResponse>
   <UpdateGroupResult>
      <Group xmlns="http://iam.amazonaws.com/doc/2010-05-08/">
         <Path>/division_abc/subdivision_xyz/product_1234/engineering/</Path>
         <GroupName>Test_1</GroupName>
         <GroupId>AGP2MAB8DPLSRHEXAMPLE</GroupId>
         <Arn>arn:aws:iam::123456789012:group/division_abc/subdivision_xyz/
         product_1234/engineering/Test_1</Arn>
      </Group>
   </UpdateGroupResult>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</UpdateGroupResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:UpdateGroupRequestMsg" wsa:Action="urn:UpdateGroup"/>
      <wsdl:output message="tns:UpdateGroupResponseMsg" wsa:Action="urn:UpdateGroup:Response"/>
    </wsdl:operation>

    <wsdl:operation name="CreateUser">
      <wsdl:documentation><![CDATA[
    <p>Creates a new user for your AWS account.</p>

    <p>For information about limitations on the number of users you can create, see 
    <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?LimitationsOnEntities.html" target="_blank">Limitations on IAM Entities</a> in <i>Using AWS Identity and Access Management</i>.</p>

    <examples>
<queryrequest>
https://iam.amazonaws.com/
?Action=CreateUser
&Path=/division_abc/subdivision_xyz/
&UserName=Bob
&Version=2010-05-08
&AUTHPARAMS
</queryrequest>

      <queryresponse>
<CreateUserResponse>
   <CreateUserResult>
      <User>
         <Path>/division_abc/subdivision_xyz/</Path>
         <UserName>Bob</UserName>
         <UserId>AIDACKCEVSQ6C2EXAMPLE</UserId>
         <Arn>arn:aws:iam::123456789012:user/division_abc/subdivision_xyz/Bob
         </Arn>
     </User>
   </CreateUserResult>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</CreateUserResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:CreateUserRequestMsg" wsa:Action="urn:CreateUser"/>
      <wsdl:output message="tns:CreateUserResponseMsg" wsa:Action="urn:CreateUser:Response"/>
    </wsdl:operation>

    <wsdl:operation name="EnableMFADevice">
      <wsdl:documentation><![CDATA[
    <p>Enables the specified MFA device and associates it with the specified user name. When enabled, the
       MFA device is required for every subsequent login by the user name associated with the device.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=EnableMFADevice
&UserName=Bob
&SerialNumber=R1234
&AuthenticationCode1=234567
&AuthenticationCode2=987654
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<EnableMFADeviceResponse>
   <ResponseMetadata>
     <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</EnableMFADeviceResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:EnableMFADeviceRequestMsg" wsa:Action="urn:EnableMFADevice"/>
      <wsdl:output message="tns:EnableMFADeviceResponseMsg" wsa:Action="urn:EnableMFADevice:Response"/>
    </wsdl:operation>

    <wsdl:operation name="DeleteAccountPasswordPolicy">
      <wsdl:documentation><![CDATA[
    <p>Deletes the password policy for the AWS account.</p>

   <examples>
      <queryrequest>
https://iam.amazonaws.com/
?Action=DeleteAccountPasswordPolicy
&Version=2010-05-08
&AUTHPARAMS
</queryrequest>

      <queryresponse>
<DeleteAccountPasswordPolicyResponse>
   <ResponseMetadata>
	   <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
	</ResponseMetadata>
</DeleteAccountPasswordPolicy>
</queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:DeleteAccountPasswordPolicyRequestMsg" wsa:Action="urn:DeleteAccountPasswordPolicy"/>
      <wsdl:output message="tns:DeleteAccountPasswordPolicyResponseMsg" wsa:Action="urn:DeleteAccountPasswordPolicy:Response"/>
    </wsdl:operation>

    <wsdl:operation name="GetLoginProfile">
      <wsdl:documentation><![CDATA[
    <p>Retrieves the user name and password create date for the specified user.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=GetLoginProfile
&UserName=Bob
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<GetLoginProfileResponse>
   <GetLoginProfileResult>
      <LoginProfile>
         <UserName>Bob</UserName>
         <CreateDate>2011-09-19T23:00:56Z</CreateDate>
      </LoginProfile>
   </GetLoginProfileResult>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</GetLoginProfileResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:GetLoginProfileRequestMsg" wsa:Action="urn:GetLoginProfile"/>
      <wsdl:output message="tns:GetLoginProfileResponseMsg" wsa:Action="urn:GetLoginProfile:Response"/>
    </wsdl:operation>

    <wsdl:operation name="UploadServerCertificate">
      <wsdl:documentation><![CDATA[
    <p>Uploads a server certificate entity for the AWS account. The server certificate entity includes a
    public key certificate, a private key, and an optional certificate chain, which should all be PEM-encoded.</p>

    <p>For information about the number of server certificates you can upload, see 
    <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?LimitationsOnEntities.html" target="_blank">Limitations on IAM Entities</a> in <i>Using AWS Identity and Access Management</i>.</p>

    <note>Because the body of the public key certificate, private key, and the certificate chain can be large,
    	you should use POST rather than GET when calling <code>UploadServerCertificate</code>. For information about setting up signatures and 
    	authorization through the API, go to <a href="http://docs.amazonwebservices.com/general/latest/gr/signing_aws_api_requests.html" target="_blank">Signing AWS API Requests</a> in the <i>AWS General Reference</i>. For general information about 
    	using the Query API with IAM, go to <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/IAM_UsingQueryAPI.html" target="_blank">Making Query Requests</a> in <i>Using IAM</i>.</note>

    <examples>
          <queryrequest>
https://iam.amazonaws.com/
?Action=UploadServerCertificate
&ServerCertificateName=ProdServerCert
&Path=/company/servercerts/
&CertificateBody=-----BEGIN CERTIFICATE-----
MIICdzCCAeCgAwIBAgIGANc+Ha2wMA0GCSqGSIb3DQEBBQUAMFMxCzAJBgNVBAYT
AlVTMRMwEQYDVQQKEwpBbWF6b24uY29tMQwwCgYDVQQLEwNBV1MxITAfBgNVBAMT
GEFXUyBMaW1pdGVkLUFzc3VyYW5jZSBDQTAeFw0wOTAyMDQxNzE5MjdaFw0xMDAy
MDQxNzE5MjdaMFIxCzAJBgNVBAYTAlVTMRMwEQYDVQQKEwpBbWF6b24uY29tMRcw
FQYDVQQLEw5BV1MtRGV2ZWxvcGVyczEVMBMGA1UEAxMMNTdxNDl0c3ZwYjRtMIGf
MA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCpB/vsOwmT/O0td1RqzKjttSBaPjbr
dqwNe9BrOyB08fw2+Ch5oonZYXfGUrT6mkYXH5fQot9HvASrzAKHO596FdJA6DmL
ywdWe1Oggk7zFSXO1Xv+3vPrJtaYxYo3eRIp7w80PMkiOv6M0XK8ubcTouODeJbf
suDqcLnLDxwsvwIDAQABo1cwVTAOBgNVHQ8BAf8EBAMCBaAwFgYDVR0lAQH/BAww
CgYIKwYBBQUHAwIwDAYDVR0TAQH/BAIwADAdBgNVHQ4EFgQULGNaBphBumaKbDRK
CAi0mH8B3mowDQYJKoZIhvcNAQEFBQADgYEAuKxhkXaCLGcqDuweKtO/AEw9ZePH
wr0XqsaIK2HZboqruebXEGsojK4Ks0WzwgrEynuHJwTn760xe39rSqXWIOGrOBaX
wFpWHVjTFMKk+tSDG1lssLHyYWWdFFU4AnejRGORJYNaRHgVTKjHphc5jEhHm0BX
AEaHzTpmEXAMPLE=
-----END CERTIFICATE-----
&PrivateKey=-----BEGIN DSA PRIVATE KEY-----
MIIBugIBTTKBgQD33xToSXPJ6hr37L3+KNi3/7DgywlBcvlFPPSHIw3ORuO/22mT
8Cy5fT89WwNvZ3BPKWU6OZ38TQv3eWjNc/3U3+oqVNG2poX5nCPOtO1b96HYX2mR
3FTdH6FRKbQEhpDzZ6tRrjTHjMX6sT3JRWkBd2c4bGu+HUHO1H7QvrCTeQIVTKMs
TCKCyrLiGhUWuUGNJUMU6y6zToGTHl84Tz7TPwDGDXuy/Dk5s4jTVr+xibROC/gS
Qrs4Dzz3T1ze6lvU8S1KT9UsOB5FUJNTTPCPey+Lo4mmK6b23XdTyCIT8e2fsm2j
jHHC1pIPiTkdLS3j6ZYjF8LY6TENFng+LDY/xwPOl7TJVoD3J/WXC2J9CEYq9o34
kq6WWn3CgYTuo54nXUgnoCb3xdG8COFrg+oTbIkHTSzs3w5o/GGgKK7TDF3UlJjq
vHNyJQ6kWBrQRR1Xp5KYQ4c/Dm5kef+62mH53HpcCELguWVcffuVQpmq3EWL9Zp9
jobTJQ2VHjb5IVxiO6HRSd27di3njyrzUuJCyHSDTqwLJmTThpd6OTIUTL3Tc4m2
62TITdw53KWJEXAMPLE=
-----END DSA PRIVATE KEY-----
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<UploadServerCertificateResponse>
  <UploadServerCertificateResult>
    <ServerCertificateMetadata>
      <ServerCertificateName>ProdServerCert</ServerCertificateName>
      <Path>/company/servercerts/</Path>
      <Arn>arn:aws:iam::123456789012:server-certificate/company/servercerts/ProdServerCert</Arn>
      <UploadDate>2010-05-08T01:02:03.004Z</UploadDate>
      <ServerCertificateId>ASCACKCEVSQ6C2EXAMPLE</ServerCertificateId>
    </ServerCertificateMetadata>
  </UploadServerCertificateResult>
  <ResponseMetadata>
    <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
  </ResponseMetadata>
</UploadServerCertificateResponse>
      </queryresponse>

    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:UploadServerCertificateRequestMsg" wsa:Action="urn:UploadServerCertificate"/>
      <wsdl:output message="tns:UploadServerCertificateResponseMsg" wsa:Action="urn:UploadServerCertificate:Response"/>
    </wsdl:operation>

    <wsdl:operation name="CreateGroup">
      <wsdl:documentation><![CDATA[
    <p>Creates a new group.</p>

    <p>For information about the number of groups you can create, 
    see <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?LimitationsOnEntities.html" target="_blank">Limitations on IAM Entities</a> in <i>Using AWS Identity and Access Management</i>.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=CreateGroup
&Path=/
&GroupName=Admins
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<CreateGroupResponse>
   <CreateGroupResult>
      <Group>
         <Path>/</Path>
         <GroupName>Admins</GroupName>
         <GroupId>AGPACKCEVSQ6C2EXAMPLE</GroupId>
         <Arn>arn:aws:iam::123456789012:group/Admins</Arn>
      </Group>
   </CreateGroupResult>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</CreateGroupResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:CreateGroupRequestMsg" wsa:Action="urn:CreateGroup"/>
      <wsdl:output message="tns:CreateGroupResponseMsg" wsa:Action="urn:CreateGroup:Response"/>
    </wsdl:operation>

    <wsdl:operation name="CreateAccountAlias">
      <wsdl:documentation><![CDATA[
    <p>This action creates an alias for your AWS account. For information about using an AWS account 
    alias, see <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/AccountAlias.html" target="_blank">Using an Alias for Your AWS Account ID</a> in <i>Using AWS Identity and Access Management</i>.</p>

    <examples>
      <queryrequest>
https://iam.amazonaws.com/
?Action=CreateAccountAlias
&AccountAlias=foocorporation
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<CreateAccountAliasResponse>
  <ResponseMetadata>
    <RequestId>36b5db08-f1b0-11df-8fbe-45274EXAMPLE</RequestId>
  </ResponseMetadata>
</CreateAccountAliasResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:CreateAccountAliasRequestMsg" wsa:Action="urn:CreateAccountAlias"/>
      <wsdl:output message="tns:CreateAccountAliasResponseMsg" wsa:Action="urn:CreateAccountAlias:Response"/>
    </wsdl:operation>

    <wsdl:operation name="DeleteUser">
      <wsdl:documentation><![CDATA[
    <p>Deletes the specified user. The user must not belong to any groups, have any keys or
    signing certificates, or have any attached policies.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=DeleteUser
&UserName=Bob
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<DeleteUserResponse>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</DeleteUserResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:DeleteUserRequestMsg" wsa:Action="urn:DeleteUser"/>
      <wsdl:output message="tns:DeleteUserResponseMsg" wsa:Action="urn:DeleteUser:Response"/>
    </wsdl:operation>

    <wsdl:operation name="DeactivateMFADevice">
      <wsdl:documentation><![CDATA[
    <p>Deactivates the specified MFA device and removes it from association with the
	user name for which it was originally enabled.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=DeactivateMFADevice
&UserName=Bob
&SerialNumber=R1234
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<DeactivateMFADeviceResponse>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</DeactivateMFADeviceResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:DeactivateMFADeviceRequestMsg" wsa:Action="urn:DeactivateMFADevice"/>
      <wsdl:output message="tns:DeactivateMFADeviceResponseMsg" wsa:Action="urn:DeactivateMFADevice:Response"/>
    </wsdl:operation>

    <wsdl:operation name="RemoveUserFromGroup">
      <wsdl:documentation><![CDATA[
    <p>Removes the specified user from the specified group.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=RemoveUserFromGroup
&GroupName=Managers
&UserName=Bob
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<RemoveUserFromGroupResponse>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</RemoveUserFromGroupResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:RemoveUserFromGroupRequestMsg" wsa:Action="urn:RemoveUserFromGroup"/>
      <wsdl:output message="tns:RemoveUserFromGroupResponseMsg" wsa:Action="urn:RemoveUserFromGroup:Response"/>
    </wsdl:operation>

    <wsdl:operation name="DeleteRole">
      <wsdl:documentation><![CDATA[
    <p>Deletes the specified role. The role must not have any attached policies.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=DeleteRole
&RoleName=S3Access
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<DeleteRoleResponse xmlns="https://iam.amazonaws.com/doc/2010-05-08/">
  <ResponseMetadata>
    <RequestId>913e3f37-99ed-11e1-a4c3-270EXAMPLE04</RequestId>
  </ResponseMetadata>
</DeleteRoleResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:DeleteRoleRequestMsg" wsa:Action="urn:DeleteRole"/>
      <wsdl:output message="tns:DeleteRoleResponseMsg" wsa:Action="urn:DeleteRole:Response"/>
    </wsdl:operation>

    <wsdl:operation name="DeleteServerCertificate">
      <wsdl:documentation><![CDATA[
    <p>Deletes the specified server certificate.</p>

    <important>If you are using a server certificate with Elastic Load Balancing, deleting 
    the certificate could have implications for your application. If Elastic Load Balancing 
    doesn't detect the deletion of bound certificates, it may continue to use the certificates.  This could
    cause Elastic Load Balancing to stop accepting traffic.  We recommend that you remove the reference to the certificate from
    Elastic Load Balancing before using this command to delete the certificate. For more information, go to <a href="http://docs.amazonwebservices.com/ElasticLoadBalancing/latest/APIReference/API_DeleteLoadBalancerListeners.html" target="blank">DeleteLoadBalancerListeners</a> in 
    the <i>Elastic Load Balancing API Reference</i>.</important>

    <examples>
      <queryrequest>
https://iam.amazonaws.com/
?Action=DeleteServerCertificate
&ServerCertificateName=ProdServerCert
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<DeleteServerCertificateResponse>
  <ResponseMetadata>
    <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
  </ResponseMetadata>
</DeleteServerCertificateResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:DeleteServerCertificateRequestMsg" wsa:Action="urn:DeleteServerCertificate"/>
      <wsdl:output message="tns:DeleteServerCertificateResponseMsg" wsa:Action="urn:DeleteServerCertificate:Response"/>
    </wsdl:operation>

    <wsdl:operation name="CreateAccessKey">
      <wsdl:documentation><![CDATA[
    <p>Creates a new AWS Secret Access Key and corresponding AWS Access Key ID for the specified user. The default
	status for new keys is <code>Active</code>.</p>

	<p>If you do not specify a user name, IAM determines the user name implicitly based on the AWS
    Access Key ID signing the request. Because this action works for access keys under the AWS account,
    you can use this API to manage root credentials even if the AWS account has no associated users.</p>

    <p>For information about limits on the number of keys you can create, see <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?LimitationsOnEntities.html" target="_blank">Limitations on IAM Entities</a> in <i>Using AWS Identity and Access Management</i>.</p>
    
    <important>To ensure the security of your AWS account, the Secret Access Key is accessible
					only during key and user creation.  You must save the key (for example, in a text
					file) if you want to be able to access it again.  If a secret key is lost, you
					can delete the access keys for the associated user and then create new keys.</important>
    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=CreateAccessKey
&UserName=Bob
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<CreateAccessKeyResponse>
   <CreateAccessKeyResult>
     <AccessKey>
         <UserName>Bob</UserName>
         <AccessKeyId>AKIAIOSFODNN7EXAMPLE</AccessKeyId>
         <Status>Active</Status>
         <SecretAccessKey>wJalrXUtnFEMI/K7MDENG/bPxRfiCYzEXAMPLEKEY
         </SecretAccessKey>
      </AccessKey>
   </CreateAccessKeyResult>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</CreateAccessKeyResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:CreateAccessKeyRequestMsg" wsa:Action="urn:CreateAccessKey"/>
      <wsdl:output message="tns:CreateAccessKeyResponseMsg" wsa:Action="urn:CreateAccessKey:Response"/>
    </wsdl:operation>

    <wsdl:operation name="GetUser">
      <wsdl:documentation><![CDATA[
    <p>Retrieves information about the specified user, including the user's path, GUID, and ARN.</p>

    <p>If you do not specify a user name, IAM determines the user name implicitly based on the AWS
    Access Key ID signing the request.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=GetUser
&UserName=Bob
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<GetUserResponse>
   <GetUserResult>
      <User>
         <Path>/division_abc/subdivision_xyz/</Path>
         <UserName>Bob</UserName>
         <UserId>AIDACKCEVSQ6C2EXAMPLE</UserId>
         <Arn>
         arn:aws:iam::123456789012:user/division_abc/subdivision_xyz/Bob
         </Arn>
      </User>
   </GetUserResult>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</GetUserResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:GetUserRequestMsg" wsa:Action="urn:GetUser"/>
      <wsdl:output message="tns:GetUserResponseMsg" wsa:Action="urn:GetUser:Response"/>
    </wsdl:operation>

    <wsdl:operation name="ResyncMFADevice">
      <wsdl:documentation><![CDATA[
    <p>Synchronizes the specified MFA device with AWS servers.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=ResyncMFADevice
&UserName=Bob
&SerialNumber=R1234
&AuthenticationCode1=234567
&AuthenticationCode2=987654
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<ResyncMFADeviceResponse>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</ResyncMFADeviceResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:ResyncMFADeviceRequestMsg" wsa:Action="urn:ResyncMFADevice"/>
      <wsdl:output message="tns:ResyncMFADeviceResponseMsg" wsa:Action="urn:ResyncMFADevice:Response"/>
    </wsdl:operation>

    <wsdl:operation name="ListMFADevices">
      <wsdl:documentation><![CDATA[
    <p>Lists the MFA devices. If the request includes the user name, then this action lists all the MFA devices associated with the specified 
      user name. If you do not specify a user name, IAM determines the user name implicitly based on the AWS
      Access Key ID signing the request.</p>

    <p>You can paginate the results using the <code>MaxItems</code> and <code>Marker</code> parameters.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=ListMFADevices
&UserName=Bob
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<ListMFADevicesResponse>
   <ListMFADevicesResult>
      <MFADevices>
         <member>
            <UserName>Bob</UserName>
            <SerialNumber>R1234</SerialNumber>
         </member>
      </MFADevices>
      <IsTruncated>false</IsTruncated>
   </ListMFADevicesResult>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</ListMFADevicesResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:ListMFADevicesRequestMsg" wsa:Action="urn:ListMFADevices"/>
      <wsdl:output message="tns:ListMFADevicesResponseMsg" wsa:Action="urn:ListMFADevices:Response"/>
    </wsdl:operation>

    <wsdl:operation name="CreateVirtualMFADevice">
      <wsdl:documentation><![CDATA[
    <p>Creates a new virtual MFA device for the AWS account. After creating the virtual MFA, use 
      <a href="http://docs.amazonwebservices.com/IAM/latest/APIReference/API_EnableMFADevice.html" target="_blank">EnableMFADevice</a>
      to attach the MFA device to an IAM user. For more information about creating and working with virtual MFA devices, go to 
      <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?Using_VirtualMFA.html" target="_blank">Using a Virtual MFA Device</a> in <i>Using AWS Identity and Access Management</i>.</p>

    <p>For information about limits on the number of MFA devices you can create, see <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?LimitationsOnEntities.html" target="_blank">Limitations on Entities</a> in <i>Using AWS Identity and Access Management</i>.</p>
    
    <important>The seed information contained in the QR code and the Base32 
      string should be treated like any other secret access information, such as your AWS access keys or your passwords. After you 
      provision your virtual device, you
      should ensure that the information is destroyed following secure procedures.</important>
    
    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=CreateVirtualMFADevice
&VirtualMFADeviceName=ExampleName
&Path=/
&Version=2010-05-08
&AUTHPARAMS
</queryrequest>

      <queryresponse>
<CreateVirtualMFADeviceResponse>
  <CreateVirtualMFADeviceResult>
    <VirtualMFADevice>
      <SerialNumber>arn:aws:iam::123456789012:mfa/ExampleName</SerialNumber>
      <Base32StringSeed>2K5K5XTLA7GGE75TQLYEXAMPLEEXAMPLEEXAMPLECHDFW4KJYZ6
      UFQ75LL7COCYKM</Base32StringSeed>
      <QRCodePNG>89504E470D0A1A0AASDFAHSDFKJKLJFKALSDFJASDF</QRCodePNG> <!-- byte array of png file -->
    </VirtualMFADevice>
  </CreateVirtualMFADeviceResult>
  <ResponseMetadata>
    <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
  </ResponseMetadata>
</CreateVirtualMFADeviceResponse>
</queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:CreateVirtualMFADeviceRequestMsg" wsa:Action="urn:CreateVirtualMFADevice"/>
      <wsdl:output message="tns:CreateVirtualMFADeviceResponseMsg" wsa:Action="urn:CreateVirtualMFADevice:Response"/>
    </wsdl:operation>

    <wsdl:operation name="ListInstanceProfiles">
      <wsdl:documentation><![CDATA[
    <p>Lists the instance profiles that have the specified path prefix. If there are none, the action returns an empty list.</p>

    <p>You can paginate the results using the <code>MaxItems</code> and <code>Marker</code> parameters.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=ListInstanceProfiles
&MaxItems=100
&PathPrefix=/application_abc/
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<ListInstanceProfilesResponse xmlns="https://iam.amazonaws.com/doc/2010-05-08/">
  <ListInstanceProfilesResult>
    <IsTruncated>false</IsTruncated>
    <InstanceProfiles>
      <member>
        <Id>AIPACIFN4OZXEXAMPLE7G</Id>
        <Roles/>
        <InstanceProfileName>Database</InstanceProfileName>
        <Path>/application_abc/component_xyz/</Path>
        <Arn>arn:aws:iam::123456789012:instance-profile/application_abc/component_xyz/Database</Arn>
        <CreateDate>2012-05-09T16:27:03Z</CreateDate>
      </member>
      <member>
        <Id>AIPACZLS2EYYEXAMPLEXM</Id>
        <Roles/>
        <InstanceProfileName>Webserver</InstanceProfileName>
        <Path>/application_abc/component_xyz/</Path>
        <Arn>arn:aws:iam::123456789012:instance-profile/application_abc/component_xyz/Webserver</Arn>
        <CreateDate>2012-05-09T16:27:11Z</CreateDate>
      </member>
    </InstanceProfiles>
  </ListInstanceProfilesResult>
  <ResponseMetadata>
    <RequestId>fd74fa8d-99f3-11e1-a4c3-27EXAMPLE804</RequestId>
  </ResponseMetadata>
</ListInstanceProfilesResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:ListInstanceProfilesRequestMsg" wsa:Action="urn:ListInstanceProfiles"/>
      <wsdl:output message="tns:ListInstanceProfilesResponseMsg" wsa:Action="urn:ListInstanceProfiles:Response"/>
    </wsdl:operation>

    <wsdl:operation name="UpdateAccessKey">
      <wsdl:documentation><![CDATA[
    <p>Changes the status of the specified access key from Active to Inactive, or vice versa.
    This action can be used to disable a user's key as part of a key rotation work flow.</p>
    
	<p>If the <code>UserName</code> field is not specified, the UserName is determined implicitly
	based on the AWS Access Key ID used to sign the request. Because this action works for access
	keys under the AWS account, this API can be used to manage root credentials even if the AWS account
	has no associated users.</p>

    <p>For information about rotating keys, see <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?ManagingCredentials.html" target="_blank">Managing Keys and Certificates</a> in <i>Using AWS Identity and Access Management</i>.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=UpdateAccessKey
&UserName=Bob
&AccessKeyId=AKIAIOSFODNN7EXAMPLE
&Status=Inactive
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<UpdateAccessKeyResponse>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</UpdateAccessKeyResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:UpdateAccessKeyRequestMsg" wsa:Action="urn:UpdateAccessKey"/>
      <wsdl:output message="tns:UpdateAccessKeyResponseMsg" wsa:Action="urn:UpdateAccessKey:Response"/>
    </wsdl:operation>

    <wsdl:operation name="AddUserToGroup">
      <wsdl:documentation><![CDATA[
    <p>Adds the specified user to the specified group.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=AddUserToGroup
&GroupName=Managers
&UserName=Bob
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<AddUserToGroupResponse>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</AddUserToGroupResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:AddUserToGroupRequestMsg" wsa:Action="urn:AddUserToGroup"/>
      <wsdl:output message="tns:AddUserToGroupResponseMsg" wsa:Action="urn:AddUserToGroup:Response"/>
    </wsdl:operation>

    <wsdl:operation name="GetGroup">
      <wsdl:documentation><![CDATA[
    <p>Returns a list of users that are in the specified group. You can paginate the results using the <code>MaxItems</code> 
    and <code>Marker</code> parameters.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=GetGroup
&GroupName=Admins
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<GetGroupResponse>
   <GetGroupResult>
      <Group>
         <Path>/</Path>
         <GroupName>Admins</GroupName>
         <GroupId>AGPACKCEVSQ6C2EXAMPLE</GroupId>
         <Arn>arn:aws:iam::123456789012:group/Admins</Arn>
      </Group>
      <Users>      
         <member>
            <Path>/division_abc/subdivision_xyz/</Path>
            <UserName>Bob</UserName>
            <UserId>AIDACKCEVSQ6C2EXAMPLE</UserId>
            <Arn>
            arn:aws:iam::123456789012:user/division_abc/subdivision_xyz/Bob
            </Arn>
         </member>
         <member>
            <Path>/division_abc/subdivision_xyz/</Path>
            <UserName>Susan</UserName>
            <UserId>AIDACKCEVSQ6C2EXAMPLE</UserId>
            <Arn>
            arn:aws:iam::123456789012:user/division_abc/subdivision_xyz/Susan
            </Arn>
         </member>
      </Users>
      <IsTruncated>false</IsTruncated>
   </GetGroupResult>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</GetGroupResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:GetGroupRequestMsg" wsa:Action="urn:GetGroup"/>
      <wsdl:output message="tns:GetGroupResponseMsg" wsa:Action="urn:GetGroup:Response"/>
    </wsdl:operation>

    <wsdl:operation name="ListAccountAliases">
      <wsdl:documentation><![CDATA[
    <p>Lists the account aliases associated with the account. For information about using an AWS account 
    alias, see <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/AccountAlias.html" target="_blank">Using an Alias for Your AWS Account ID</a> in <i>Using AWS Identity and Access Management</i>.</p>

    <p>You can paginate the results using the <code>MaxItems</code> and <code>Marker</code> parameters.</p>    
    
    <examples>
      <queryrequest>
https://iam.amazonaws.com/
?Action=ListAccountAliases
&Version=2010-05-08
&AUTHPARAMS      
      </queryrequest>

      <queryresponse>
<ListAccountAliasesResponse>
  <ListAccountAliasesResult>
    <IsTruncated>false</IsTruncated>
    <AccountAliases>
      <member>foocorporation</member>
    </AccountAliases>
  </ListAccountAliasesResult>
  <ResponseMetadata>
    <RequestId>c5a076e9-f1b0-11df-8fbe-45274EXAMPLE</RequestId>
  </ResponseMetadata>
</ListAccountAliasesResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:ListAccountAliasesRequestMsg" wsa:Action="urn:ListAccountAliases"/>
      <wsdl:output message="tns:ListAccountAliasesResponseMsg" wsa:Action="urn:ListAccountAliases:Response"/>
    </wsdl:operation>

    <wsdl:operation name="DeleteGroup">
      <wsdl:documentation><![CDATA[
    <p>Deletes the specified group. The group must not contain any users or have any attached policies.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=DeleteGroup
&Group=Test
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<DeleteGroupResponse>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</DeleteGroupResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:DeleteGroupRequestMsg" wsa:Action="urn:DeleteGroup"/>
      <wsdl:output message="tns:DeleteGroupResponseMsg" wsa:Action="urn:DeleteGroup:Response"/>
    </wsdl:operation>

    <wsdl:operation name="GetRole">
      <wsdl:documentation><![CDATA[
    <p>Retrieves information about the specified role, including the role's path, GUID, ARN, and the assume role policy.</p>

    <p>The returned policy is URL-encoded according to RFC 3986. For more information about
       RFC 3986, go to <a href="http://www.faqs.org/rfcs/rfc3986.html">http://www.faqs.org/rfcs/rfc3986.html</a>.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=GetRole
&RoleName=S3Access
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<GetRoleResponse xmlns="https://iam.amazonaws.com/doc/2010-05-08/">
  <GetRoleResult>
    <Role>
      <Path>/application_abc/component_xyz/</Path>
      <Arn>arn:aws:iam::123456789012:role/application_abc/component_xyz/S3Access</Arn>
      <RoleName>S3Access</RoleName>
      <AssumeRolePolicyDocument>{"Version":"2008-10-17","Statement":[{"Effect":"Allow","Principal":{"Service":["ec2.amazonaws.com"]},"Action":["sts:AssumeRole"]}]}</AssumeRolePolicyDocument>
      <CreateDate>2012-05-08T23:34:01Z</CreateDate>
      <RoleId>AROADBQP57FF2AEXAMPLE</RoleId>
    </Role>
  </GetRoleResult>
  <ResponseMetadata>
    <RequestId>df37e965-9967-11e1-a4c3-270EXAMPLE04</RequestId>
  </ResponseMetadata>
</GetRoleResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:GetRoleRequestMsg" wsa:Action="urn:GetRole"/>
      <wsdl:output message="tns:GetRoleResponseMsg" wsa:Action="urn:GetRole:Response"/>
    </wsdl:operation>

    <wsdl:operation name="ListRolePolicies">
      <wsdl:documentation><![CDATA[
    <p>Lists the names of the policies associated with the specified role. If there are none,
    the action returns an empty list.</p>

    <p>You can paginate the results using the <code>MaxItems</code> and <code>Marker</code> parameters.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=ListRolePolicies
&MaxItems=100
&RoleName=S3Access
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<ListRolePoliciesResponse xmlns="https://iam.amazonaws.com/doc/2010-05-08/">
  <ListRolePoliciesResult>
    <PolicyNames>
      <member>CloudwatchPutMetricPolicy</member>
      <member>S3AccessPolicy</member>
    </PolicyNames>
    <IsTruncated>false</IsTruncated>
  </ListRolePoliciesResult>
  <ResponseMetadata>
    <RequestId>8c7e1816-99f0-11e1-a4c3-27EXAMPLE804</RequestId>
  </ResponseMetadata>
</ListRolePoliciesResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:ListRolePoliciesRequestMsg" wsa:Action="urn:ListRolePolicies"/>
      <wsdl:output message="tns:ListRolePoliciesResponseMsg" wsa:Action="urn:ListRolePolicies:Response"/>
    </wsdl:operation>

    <wsdl:operation name="ListSigningCertificates">
      <wsdl:documentation><![CDATA[
    <p>Returns information about the signing certificates associated with the specified user. If there
    are none, the action returns an empty list.</p>

    <p>Although each user is limited to a small number of signing certificates, you can still paginate
      the results using the <code>MaxItems</code> and <code>Marker</code> parameters.</p>

	<p>If the <code>UserName</code> field is not specified, the user name is determined implicitly
	based on the AWS Access Key ID used to sign the request. Because this action works for access
	keys under the AWS account, this API can be used to manage root credentials even if the AWS account has
	no associated users.</p>


    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=ListSigningCertificates
&UserName=Bob
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<ListSigningCertificatesResponse>
   <ListSigningCertificatesResult>
      <UserName>Bob</UserName>
      <Certificates>
         <member>
            <UserName>Bob</UserName>
            <CertificateId>TA7SMP42TDN5Z26OBPJE7EXAMPLE</CertificateId>
            <CertificateBody>-----BEGIN CERTIFICATE-----
    MIICdzCCAeCgAwIBAgIGANc+Ha2wMA0GCSqGSIb3DQEBBQUAMFMxCzAJBgNVBAYT
    AlVTMRMwEQYDVQQKEwpBbWF6b24uY29tMQwwCgYDVQQLEwNBV1MxITAfBgNVBAMT
    GEFXUyBMaW1pdGVkLUFzc3VyYW5jZSBDQTAeFw0wOTAyMDQxNzE5MjdaFw0xMDAy
    MDQxNzE5MjdaMFIxCzAJBgNVBAYTAlVTMRMwEQYDVQQKEwpBbWF6b24uY29tMRcw
    FQYDVQQLEw5BV1MtRGV2ZWxvcGVyczEVMBMGA1UEAxMMNTdxNDl0c3ZwYjRtMIGf
    MA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCpB/vsOwmT/O0td1RqzKjttSBaPjbr
    dqwNe9BrOyB08fw2+Ch5oonZYXfGUrT6mkYXH5fQot9HvASrzAKHO596FdJA6DmL
    ywdWe1Oggk7zFSXO1Xv+3vPrJtaYxYo3eRIp7w80PMkiOv6M0XK8ubcTouODeJbf
    suDqcLnLDxwsvwIDAQABo1cwVTAOBgNVHQ8BAf8EBAMCBaAwFgYDVR0lAQH/BAww
    CgYIKwYBBQUHAwIwDAYDVR0TAQH/BAIwADAdBgNVHQ4EFgQULGNaBphBumaKbDRK
    CAi0mH8B3mowDQYJKoZIhvcNAQEFBQADgYEAuKxhkXaCLGcqDuweKtO/AEw9ZePH
    wr0XqsaIK2HZboqruebXEGsojK4Ks0WzwgrEynuHJwTn760xe39rSqXWIOGrOBaX
    wFpWHVjTFMKk+tSDG1lssLHyYWWdFFU4AnejRGORJYNaRHgVTKjHphc5jEhHm0BX
    AEaHzTpmEXAMPLE=
    -----END CERTIFICATE-----</CertificateBody>
            <Status>Active</Status>
         </member>
      </Certificates>
      <IsTruncated>false</IsTruncated>
   </ListSigningCertificatesResult>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</ListSigningCertificatesResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:ListSigningCertificatesRequestMsg" wsa:Action="urn:ListSigningCertificates"/>
      <wsdl:output message="tns:ListSigningCertificatesResponseMsg" wsa:Action="urn:ListSigningCertificates:Response"/>
    </wsdl:operation>

    <wsdl:operation name="UploadSigningCertificate">
      <wsdl:documentation><![CDATA[
    <p>Uploads an X.509 signing certificate and associates it with the specified user. Some AWS services
	use X.509 signing certificates to validate requests that are signed with a
    corresponding private key. When you upload the certificate, its default status is <code>Active</code>.</p>

	<p>If the <code>UserName</code> field is not specified, the user name is determined implicitly
	based on the AWS Access Key ID used to sign the request. Because this action works for access
	keys under the AWS account, this API can be used to manage root credentials even if the AWS account
	has no associated users.</p>

    <note>Because the body of a X.509 certificate can be large, you should use POST rather than GET when
    	calling <code>UploadSigningCertificate</code>. For information about setting up signatures and 
    	authorization through the API, go to <a href="http://docs.amazonwebservices.com/general/latest/gr/signing_aws_api_requests.html" target="_blank">Signing AWS API Requests</a> in the <i>AWS General Reference</i>. For general information about 
    	using the Query API with IAM, go to <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/IAM_UsingQueryAPI.html" target="_blank">Making Query Requests</a> in <i>Using IAM</i>.</note>

    <examples>

      <queryrequest>
POST / HTTP/1.1
Host: iam.amazonaws.com
Content-Type: application/x-www-form-urlencoded

Action=UploadSigningCertificate
&UserName=Bob
&CertificateBody=-----BEGIN CERTIFICATE-----
    MIICdzCCAeCgAwIBAgIGANc+Ha2wMA0GCSqGSIb3DQEBBQUAMFMxCzAJBgNVBAYT
    AlVTMRMwEQYDVQQKEwpBbWF6b24uY29tMQwwCgYDVQQLEwNBV1MxITAfBgNVBAMT
    GEFXUyBMaW1pdGVkLUFzc3VyYW5jZSBDQTAeFw0wOTAyMDQxNzE5MjdaFw0xMDAy
    MDQxNzE5MjdaMFIxCzAJBgNVBAYTAlVTMRMwEQYDVQQKEwpBbWF6b24uY29tMRcw
    FQYDVQQLEw5BV1MtRGV2ZWxvcGVyczEVMBMGA1UEAxMMNTdxNDl0c3ZwYjRtMIGf
    MA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCpB/vsOwmT/O0td1RqzKjttSBaPjbr
    dqwNe9BrOyB08fw2+Ch5oonZYXfGUrT6mkYXH5fQot9HvASrzAKHO596FdJA6DmL
    ywdWe1Oggk7zFSXO1Xv+3vPrJtaYxYo3eRIp7w80PMkiOv6M0XK8ubcTouODeJbf
    suDqcLnLDxwsvwIDAQABo1cwVTAOBgNVHQ8BAf8EBAMCBaAwFgYDVR0lAQH/BAww
    CgYIKwYBBQUHAwIwDAYDVR0TAQH/BAIwADAdBgNVHQ4EFgQULGNaBphBumaKbDRK
    CAi0mH8B3mowDQYJKoZIhvcNAQEFBQADgYEAuKxhkXaCLGcqDuweKtO/AEw9ZePH
    wr0XqsaIK2HZboqruebXEGsojK4Ks0WzwgrEynuHJwTn760xe39rSqXWIOGrOBaX
    wFpWHVjTFMKk+tSDG1lssLHyYWWdFFU4AnejRGORJYNaRHgVTKjHphc5jEhHm0BX
    AEaHzTpmEXAMPLE=
    -----END CERTIFICATE-----
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<UploadSigningCertificateResponse>
   <UploadSigningCertificateResult>
      <Certificate>
         <UserName>Bob</UserName>
         <CertificateId>TA7SMP42TDN5Z26OBPJE7EXAMPLE</CertificateId>
         <CertificateBody>-----BEGIN CERTIFICATE-----
    MIICdzCCAeCgAwIBAgIGANc+Ha2wMA0GCSqGSIb3DQEBBQUAMFMxCzAJBgNVBAYT
    AlVTMRMwEQYDVQQKEwpBbWF6b24uY29tMQwwCgYDVQQLEwNBV1MxITAfBgNVBAMT
    GEFXUyBMaW1pdGVkLUFzc3VyYW5jZSBDQTAeFw0wOTAyMDQxNzE5MjdaFw0xMDAy
    MDQxNzE5MjdaMFIxCzAJBgNVBAYTAlVTMRMwEQYDVQQKEwpBbWF6b24uY29tMRcw
    FQYDVQQLEw5BV1MtRGV2ZWxvcGVyczEVMBMGA1UEAxMMNTdxNDl0c3ZwYjRtMIGf
    MA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCpB/vsOwmT/O0td1RqzKjttSBaPjbr
    dqwNe9BrOyB08fw2+Ch5oonZYXfGUrT6mkYXH5fQot9HvASrzAKHO596FdJA6DmL
    ywdWe1Oggk7zFSXO1Xv+3vPrJtaYxYo3eRIp7w80PMkiOv6M0XK8ubcTouODeJbf
    suDqcLnLDxwsvwIDAQABo1cwVTAOBgNVHQ8BAf8EBAMCBaAwFgYDVR0lAQH/BAww
    CgYIKwYBBQUHAwIwDAYDVR0TAQH/BAIwADAdBgNVHQ4EFgQULGNaBphBumaKbDRK
    CAi0mH8B3mowDQYJKoZIhvcNAQEFBQADgYEAuKxhkXaCLGcqDuweKtO/AEw9ZePH
    wr0XqsaIK2HZboqruebXEGsojK4Ks0WzwgrEynuHJwTn760xe39rSqXWIOGrOBaX
    wFpWHVjTFMKk+tSDG1lssLHyYWWdFFU4AnejRGORJYNaRHgVTKjHphc5jEhHm0BX
    AEaHzTpmEXAMPLE=
    -----END CERTIFICATE-----</CertificateBody>
         <Status>Active</Status>
      </Certificate>
   </UploadSigningCertificateResult>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</UploadSigningCertificateResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:UploadSigningCertificateRequestMsg" wsa:Action="urn:UploadSigningCertificate"/>
      <wsdl:output message="tns:UploadSigningCertificateResponseMsg" wsa:Action="urn:UploadSigningCertificate:Response"/>
    </wsdl:operation>

    <wsdl:operation name="DeleteInstanceProfile">
      <wsdl:documentation><![CDATA[
    <p>Deletes the specified instance profile. The instance profile must not have an associated role.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=DeleteInstanceProfile
&InstanceProfileName=Webserver
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>
      <queryresponse>
<DeleteInstanceProfileResponse xmlns="https://iam.amazonaws.com/doc/2010-05-08/">
  <ResponseMetadata>
    <RequestId>90c18667-99f3-11e1-a4c3-27EXAMPLE804</RequestId>
  </ResponseMetadata>
</DeleteInstanceProfileResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:DeleteInstanceProfileRequestMsg" wsa:Action="urn:DeleteInstanceProfile"/>
      <wsdl:output message="tns:DeleteInstanceProfileResponseMsg" wsa:Action="urn:DeleteInstanceProfile:Response"/>
    </wsdl:operation>

    <wsdl:operation name="CreateRole">
      <wsdl:documentation><![CDATA[
    <p>Creates a new role for your AWS account.</p>

    <p>For information about limitations on the number of roles you can create, see 
    <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?LimitationsOnEntities.html" target="_blank">Limitations on IAM Entities</a> in <i>Using AWS Identity and Access Management</i>.</p>

    <p>The returned policy is URL-encoded according to RFC 3986. For more information about
       RFC 3986, go to <a href="http://www.faqs.org/rfcs/rfc3986.html">http://www.faqs.org/rfcs/rfc3986.html</a>.</p>

    <examples>
<queryrequest>
https://iam.amazonaws.com/
?Action=CreateRole
&RoleName=S3Access
&Path=/application_abc/component_xyz/
&AssumeRolePolicyDocument={"Version":"2008-10-17","Statement":[{"Effect":"Allow","Principal":{"Service":["ec2.amazonaws.com"]},"Action":["sts:AssumeRole"]}]}
&Version=2010-05-08
&AUTHPARAMS
</queryrequest>

      <queryresponse>
<CreateRoleResponse xmlns="https://iam.amazonaws.com/doc/2010-05-08/">
  <CreateRoleResult>
    <Role>
      <Path>/application_abc/component_xyz/</Path>
      <Arn>arn:aws:iam::123456789012:role/application_abc/component_xyz/S3Access</Arn>
      <RoleName>S3Access</RoleName>
      <AssumeRolePolicyDocument>{"Version":"2008-10-17","Statement":[{"Effect":"Allow","Principal":{"Service":["ec2.amazonaws.com"]},"Action":["sts:AssumeRole"]}]}</AssumeRolePolicyDocument>
      <CreateDate>2012-05-08T23:34:01.495Z</CreateDate>
      <RoleId>AROADBQP57FF2AEXAMPLE</RoleId>
    </Role>
  </CreateRoleResult>
  <ResponseMetadata>
    <RequestId>4a93ceee-9966-11e1-b624-b1aEXAMPLE7c</RequestId>
  </ResponseMetadata>
</CreateRoleResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:CreateRoleRequestMsg" wsa:Action="urn:CreateRole"/>
      <wsdl:output message="tns:CreateRoleResponseMsg" wsa:Action="urn:CreateRole:Response"/>
    </wsdl:operation>

    <wsdl:operation name="UpdateLoginProfile">
      <wsdl:documentation><![CDATA[
    <p>Changes the password for the specified user.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=UpdateLoginProfile
&UserName=Bob
&Password=NewPassword
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<UpdateLoginProfileResponse>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</UpdateLoginProfileResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:UpdateLoginProfileRequestMsg" wsa:Action="urn:UpdateLoginProfile"/>
      <wsdl:output message="tns:UpdateLoginProfileResponseMsg" wsa:Action="urn:UpdateLoginProfile:Response"/>
    </wsdl:operation>

    <wsdl:operation name="DeleteLoginProfile">
      <wsdl:documentation><![CDATA[
    <p>Deletes the password for the specified user, which terminates the user's ability to access AWS
       services through the AWS Management Console.</p>
    <important>Deleting a user's password does not prevent a user from accessing IAM through the
    command line interface or the API.  To prevent all user access you must also either make the access
	key inactive or delete it.  For more information about making keys inactive or deleting them, see
	<a>UpdateAccessKey</a> and <a>DeleteAccessKey</a>.
    </important>
       
    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=DeleteLoginProfile
&UserName=Bob
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<DeleteLoginProfileResponse>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</DeleteLoginProfileResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:DeleteLoginProfileRequestMsg" wsa:Action="urn:DeleteLoginProfile"/>
      <wsdl:output message="tns:DeleteLoginProfileResponseMsg" wsa:Action="urn:DeleteLoginProfile:Response"/>
    </wsdl:operation>

    <wsdl:operation name="ChangePassword">
      <wsdl:documentation><![CDATA[
  	<p>Changes the password of the IAM user calling <code>ChangePassword</code>. The root account 
  		password is not affected by this action. For information about modifying passwords, see <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/Using_ManagingLogins.html" target="_blank">Managing Passwords</a>.</p>
       
    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=ChangePassword
&OldPassword=U79}kgds4?
&NewPassword=Lb0*1(9xpN
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<ChangePasswordResponse>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</ChangepasswordResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:ChangePasswordRequestMsg" wsa:Action="urn:ChangePassword"/>
      <wsdl:output message="tns:ChangePasswordResponseMsg" wsa:Action="urn:ChangePassword:Response"/>
    </wsdl:operation>

    <wsdl:operation name="GetServerCertificate">
      <wsdl:documentation><![CDATA[
    <p>Retrieves information about the specified server certificate.</p>

    <examples>
      <queryrequest>
https://iam.amazonaws.com/
?Action=GetServerCertificate
&ServerCertificateName=ProdServerCert
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<GetServerCertificateResponse>
  <GetServerCertificateResult>
    <ServerCertificate>
      <ServerCertificateMetadata>
        <ServerCertificateName>ProdServerCert</ServerCertificateName>
        <Path>/company/servercerts/</Path>
        <Arn>arn:aws:iam::123456789012:server-certificate/company/servercerts/ProdServerCert</Arn>
        <UploadDate>2010-05-08T01:02:03.004Z</UploadDate>
        <ServerCertificateId>ASCACKCEVSQ6C2EXAMPLE</ServerCertificateId>
      </ServerCertificateMetadata>
      <CertificateBody>-----BEGIN CERTIFICATE-----
MIICdzCCAeCgAwIBAgIGANc+Ha2wMA0GCSqGSIb3DQEBBQUAMFMxCzAJBgNVBAYT
AlVTMRMwEQYDVQQKEwpBbWF6b24uY29tMQwwCgYDVQQLEwNBV1MxITAfBgNVBAMT
GEFXUyBMaW1pdGVkLUFzc3VyYW5jZSBDQTAeFw0wOTAyMDQxNzE5MjdaFw0xMDAy
MDQxNzE5MjdaMFIxCzAJBgNVBAYTAlVTMRMwEQYDVQQKEwpBbWF6b24uY29tMRcw
FQYDVQQLEw5BV1MtRGV2ZWxvcGVyczEVMBMGA1UEAxMMNTdxNDl0c3ZwYjRtMIGf
MA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCpB/vsOwmT/O0td1RqzKjttSBaPjbr
dqwNe9BrOyB08fw2+Ch5oonZYXfGUrT6mkYXH5fQot9HvASrzAKHO596FdJA6DmL
ywdWe1Oggk7zFSXO1Xv+3vPrJtaYxYo3eRIp7w80PMkiOv6M0XK8ubcTouODeJbf
suDqcLnLDxwsvwIDAQABo1cwVTAOBgNVHQ8BAf8EBAMCBaAwFgYDVR0lAQH/BAww
CgYIKwYBBQUHAwIwDAYDVR0TAQH/BAIwADAdBgNVHQ4EFgQULGNaBphBumaKbDRK
CAi0mH8B3mowDQYJKoZIhvcNAQEFBQADgYEAuKxhkXaCLGcqDuweKtO/AEw9ZePH
wr0XqsaIK2HZboqruebXEGsojK4Ks0WzwgrEynuHJwTn760xe39rSqXWIOGrOBaX
wFpWHVjTFMKk+tSDG1lssLHyYWWdFFU4AnejRGORJYNaRHgVTKjHphc5jEhHm0BX
AEaHzTpmEXAMPLE=
-----END CERTIFICATE-----
      </CertificateBody>
    </ServerCertificate>
  </GetServerCertificateResult>
  <ResponseMetadata>
    <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
  </ResponseMetadata>
</GetServerCertificateResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:GetServerCertificateRequestMsg" wsa:Action="urn:GetServerCertificate"/>
      <wsdl:output message="tns:GetServerCertificateResponseMsg" wsa:Action="urn:GetServerCertificate:Response"/>
    </wsdl:operation>

    <wsdl:operation name="PutGroupPolicy">
      <wsdl:documentation><![CDATA[
    <p>Adds (or updates) a policy document associated with the specified group. For information about
    policies, refer to <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?PoliciesOverview.html" target="_blank">Overview of Policies</a> in <i>Using AWS Identity and Access Management</i>.</p>

    <p>For information about limits on the number of policies you can associate with a group, see
    <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?LimitationsOnEntities.html" target="_blank">Limitations on IAM Entities</a> in <i>Using AWS Identity and Access Management</i>.</p>

    <note>Because policy documents can be large, you should use POST rather than GET when
    	calling <code>PutGroupPolicy</code>. For information about setting up signatures and 
    	authorization through the API, go to <a href="http://docs.amazonwebservices.com/general/latest/gr/signing_aws_api_requests.html" target="_blank">Signing AWS API Requests</a> in the <i>AWS General Reference</i>. For general information about 
    	using the Query API with IAM, go to <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/IAM_UsingQueryAPI.html" target="_blank">Making Query Requests</a> in <i>Using IAM</i>.</note>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=PutGroupPolicy
&GroupName=Admins
&PolicyName=AdminRoot
&PolicyDocument={"Statement":[{"Effect":"Allow","Action":"*","Resource":"*"}]}
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<PutGroupPolicyResponse>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</PutGroupPolicyResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:PutGroupPolicyRequestMsg" wsa:Action="urn:PutGroupPolicy"/>
      <wsdl:output message="tns:PutGroupPolicyResponseMsg" wsa:Action="urn:PutGroupPolicy:Response"/>
    </wsdl:operation>

    <wsdl:operation name="DeleteSigningCertificate">
      <wsdl:documentation><![CDATA[
    <p>Deletes the specified signing certificate associated with the specified user.</p>

<p>If you do not specify a user name, IAM determines the user name implicitly based on the AWS
    Access Key ID signing the request. Because this action works for access keys under the AWS account,
    you can use this API to manage root credentials even if the AWS account has no associated users.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=DeleteSigningCertificate
&UserName=Bob
&CertificateId=TA7SMP42TDN5Z26OBPJE7EXAMPLE
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<DeleteSigningCertificateResponse>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</DeleteSigningCertificateResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:DeleteSigningCertificateRequestMsg" wsa:Action="urn:DeleteSigningCertificate"/>
      <wsdl:output message="tns:DeleteSigningCertificateResponseMsg" wsa:Action="urn:DeleteSigningCertificate:Response"/>
    </wsdl:operation>

    <wsdl:operation name="ListUserPolicies">
      <wsdl:documentation><![CDATA[
    <p>Lists the names of the policies associated with the specified user. If there are none,
    the action returns an empty list.</p>

    <p>You can paginate the results using the <code>MaxItems</code> and <code>Marker</code> parameters.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=ListUserPolicies
&UserName=Bob
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<ListUserPoliciesResponse>
   <ListUserPoliciesResult>
      <PolicyNames>
         <member>AllAccessPolicy</member>
         <member>KeyPolicy</member>
      </PolicyNames>
      <IsTruncated>false</IsTruncated>
   </ListUserPoliciesResult>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</ListUserPoliciesResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:ListUserPoliciesRequestMsg" wsa:Action="urn:ListUserPolicies"/>
      <wsdl:output message="tns:ListUserPoliciesResponseMsg" wsa:Action="urn:ListUserPolicies:Response"/>
    </wsdl:operation>

    <wsdl:operation name="ListAccessKeys">
      <wsdl:documentation><![CDATA[
    <p>Returns information about the Access Key IDs associated with the specified user. If there are none,
    the action returns an empty list.</p>

    <p>Although each user is limited to a small number of keys, you can still paginate the results
    using the <code>MaxItems</code> and <code>Marker</code> parameters.</p>
    
	<p>If the <code>UserName</code> field is not specified, the UserName is determined implicitly based
	on the AWS Access Key ID used to sign the request. Because this action works for access keys under
	the AWS account, this API can be used to manage root credentials even if the AWS account has no associated users.</p>

<note>To ensure the security of your AWS account, the secret access key is accessible only during key and user creation.</note>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=ListAccessKeys
&UserName=Bob
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<ListAccessKeysResponse>
   <ListAccessKeysResult>
      <UserName>Bob</UserName>
      <AccessKeyMetadata>
         <member>
            <UserName>Bob</UserName>
            <AccessKeyId>AKIAIOSFODNN7EXAMPLE</AccessKeyId>
            <Status>Active</Status>
         </member>
         <member>
            <UserName>Bob</UserName>
            <AccessKeyId>AKIAI44QH8DHBEXAMPLE</AccessKeyId>
            <Status>Inactive</Status>
         </member>
      </AccessKeyMetadata>
      <IsTruncated>false</IsTruncated>
   </ListAccessKeysResult>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</ListAccessKeysResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:ListAccessKeysRequestMsg" wsa:Action="urn:ListAccessKeys"/>
      <wsdl:output message="tns:ListAccessKeysResponseMsg" wsa:Action="urn:ListAccessKeys:Response"/>
    </wsdl:operation>

    <wsdl:operation name="ListGroupsForUser">
      <wsdl:documentation><![CDATA[
    <p>Lists the groups the specified user belongs to.</p>
     
    <p>You can paginate the results using the <code>MaxItems</code> and <code>Marker</code> parameters.</p>

    <examples>

      <queryrequest> 
https://iam.amazonaws.com/
?Action=ListGroupsForUser
&UserName=Bob
&AUTHPARAMS
       </queryrequest>

      <queryresponse> 
<ListGroupsForUserResponse> 
   <ListGroupsForUserResult>
      <Groups>
         <member>
            <Path>/</Path>
            <GroupName>Admins</GroupName>
            <GroupId>AGPACKCEVSQ6C2EXAMPLE</GroupId>
            <Arn>arn:aws:iam::123456789012:group/Admins</Arn>
         </member>
      </Groups>
      <IsTruncated>false</IsTruncated>
   </ListGroupsForUserResult>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</ListGroupsForUserResponse>
</queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:ListGroupsForUserRequestMsg" wsa:Action="urn:ListGroupsForUser"/>
      <wsdl:output message="tns:ListGroupsForUserResponseMsg" wsa:Action="urn:ListGroupsForUser:Response"/>
    </wsdl:operation>

    <wsdl:operation name="AddRoleToInstanceProfile">
      <wsdl:documentation><![CDATA[
    <p>Adds the specified role to the specified instance profile.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=AddRoleToInstanceProfile
&InstanceProfileName=Webserver
&RoleName=S3Access
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>
  <ResponseMetadata>
  </ResponseMetadata>

      <queryresponse>
<AddRoleToInstanceProfileResponse xmlns="https://iam.amazonaws.com/doc/2010-05-08/">
  <ResponseMetadata>
    <RequestId>12657608-99f2-11e1-a4c3-27EXAMPLE804</RequestId>
  </ResponseMetadata>
</AddRoleToInstanceProfileResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:AddRoleToInstanceProfileRequestMsg" wsa:Action="urn:AddRoleToInstanceProfile"/>
      <wsdl:output message="tns:AddRoleToInstanceProfileResponseMsg" wsa:Action="urn:AddRoleToInstanceProfile:Response"/>
    </wsdl:operation>

    <wsdl:operation name="GetGroupPolicy">
      <wsdl:documentation><![CDATA[
    <p>Retrieves the specified policy document for the specified group. The returned policy is URL-encoded
    according to RFC 3986. For more information about RFC 3986, go to <a href="http://www.faqs.org/rfcs/rfc3986.html">http://www.faqs.org/rfcs/rfc3986.html</a>.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=GetGroupPolicy
&GroupName=Admins
&PolicyName=AdminRoot
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<GetGroupPolicyResponse>
   <GetGroupPolicyResult>
      <GroupName>Admins</GroupName>
      <PolicyName>AdminRoot</PolicyName>
      <PolicyDocument>
      {"Statement":[{"Effect":"Allow","Action":"*","Resource":"*"}]}
      </PolicyDocument>
   </GetGroupPolicyResult>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</GetGroupPolicyResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:GetGroupPolicyRequestMsg" wsa:Action="urn:GetGroupPolicy"/>
      <wsdl:output message="tns:GetGroupPolicyResponseMsg" wsa:Action="urn:GetGroupPolicy:Response"/>
    </wsdl:operation>

    <wsdl:operation name="GetRolePolicy">
      <wsdl:documentation><![CDATA[
    <p>Retrieves the specified policy document for the specified role. The returned policy is URL-encoded
    according to RFC 3986. For more information about RFC 3986, go to <a href="http://www.faqs.org/rfcs/rfc3986.html">http://www.faqs.org/rfcs/rfc3986.html</a>.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=GetRolePolicy
&PolicyName=S3AccessPolicy
&RoleName=S3Access
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<GetRolePolicyResponse xmlns="https://iam.amazonaws.com/doc/2010-05-08/">
  <GetRolePolicyResult>
    <PolicyName>S3AccessPolicy</PolicyName>
    <RoleName>S3Access</RoleName>
    <PolicyDocument>{"Version":"2008-10-17","Statement":[{"Effect":"Allow","Action":["s3:*"],"Resource":["*"]}]}</PolicyDocument>
  </GetRolePolicyResult>
  <ResponseMetadata>
    <RequestId>7e7cd8bc-99ef-11e1-a4c3-27EXAMPLE804</RequestId>
  </ResponseMetadata>
</GetRolePolicyResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:GetRolePolicyRequestMsg" wsa:Action="urn:GetRolePolicy"/>
      <wsdl:output message="tns:GetRolePolicyResponseMsg" wsa:Action="urn:GetRolePolicy:Response"/>
    </wsdl:operation>

    <wsdl:operation name="ListInstanceProfilesForRole">
      <wsdl:documentation><![CDATA[
    <p>Lists the instance profiles that have the specified associated role. If there are none, the action returns an empty list.</p>

    <p>You can paginate the results using the <code>MaxItems</code> and <code>Marker</code> parameters.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=ListInstanceProfilesForRole
&MaxItems=100
&RoleName=S3Access
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>
      <queryresponse>
<ListInstanceProfilesForRoleResponse xmlns="https://iam.amazonaws.com/doc/2010-05-08/">
  <ListInstanceProfilesForRoleResult>
    <IsTruncated>false</IsTruncated>
    <InstanceProfiles>
      <member>
        <Id>AIPACZLS2EYYEXAMPLEXM</Id>
        <Roles>
          <member>
            <Path>/application_abc/component_xyz/</Path>
            <Arn>arn:aws:iam::123456789012:role/application_abc/component_xyz/S3Access</Arn>
            <RoleName>S3Access</RoleName>
            <AssumeRolePolicyDocument>{"Version":"2008-10-17","Statement":[{"Effect":"Allow","Principal":{"Service":["ec2.amazonaws.com"]},"Action":["sts:AssumeRole"]}]}</AssumeRolePolicyDocument>
            <CreateDate>2012-05-09T15:45:35Z</CreateDate>
            <RoleId>AROACVSVTSZ3EXAMPLEYK</RoleId>
          </member>
        </Roles>
        <InstanceProfileName>Webserver</InstanceProfileName>
        <Path>/application_abc/component_xyz/</Path>
        <Arn>arn:aws:iam::123456789012:instance-profile/application_abc/component_xyz/Webserver</Arn>
        <CreateDate>2012-05-09T16:27:11Z</CreateDate>
      </member>
    </InstanceProfiles>
  </ListInstanceProfilesForRoleResult>
  <ResponseMetadata>
    <RequestId>6a8c3992-99f4-11e1-a4c3-27EXAMPLE804</RequestId>
  </ResponseMetadata>
</ListInstanceProfilesForRoleResponse>

      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:ListInstanceProfilesForRoleRequestMsg" wsa:Action="urn:ListInstanceProfilesForRole"/>
      <wsdl:output message="tns:ListInstanceProfilesForRoleResponseMsg" wsa:Action="urn:ListInstanceProfilesForRole:Response"/>
    </wsdl:operation>

    <wsdl:operation name="ListVirtualMFADevices">
      <wsdl:documentation><![CDATA[
    <p>
      Lists the virtual MFA devices under the AWS account by assignment status. If you do not specify an
      assignment status, the action returns a list of all virtual MFA devices. Assignment status can be <code>Assigned</code>, 
      <code>Unassigned</code>, or <code>Any</code>.
    </p>

    <p>You can paginate the results using the <code>MaxItems</code> and <code>Marker</code> parameters.</p>

    <examples>
      
<queryrequest>
<!-- This example shows the request where 
     the AssignmentStatus is Any -->
  
https://iam.amazonaws.com/
?Action=ListVirtualMFADevices
&AssignmentStatus=Any
&AUTHPARAMS
</queryrequest>

      <queryresponse>
<!-- The action returns all three virtual MFA devices
     associated with the account: the first device is
     unassigned, the second is assigned to the root 
     account, and the third is assigned to a user 
     named ExampleUser under the account. -->

<ListVirtualMFADevicesResponse>
  <ListVirtualMFADevicesResult>
    <IsTruncated>false</IsTruncated>
    <VirtualMFADevices>
      <member>
        <SerialNumber>
        arn:aws:iam::123456789012:mfa/MFAdeviceName
        </SerialNumber>
      </member>
      <member>
        <SerialNumber>
        arn:aws:iam::123456789012:mfa/RootMFAdeviceName
        </SerialNumber>
        <EnableDate>2011-10-20T20:49:03Z</EnableDate>
        <User>
          <UserId>123456789012</UserId>
          <Arn>arn:aws:iam::123456789012:root</Arn>
          <CreateDate>2009-10-13T22:00:36Z</CreateDate>
        </User>
      </member>
      <member>
        <SerialNumber>
        arn:aws:iam:::mfa/ExampleUserMFAdeviceName
        </SerialNumber>
        <EnableDate>2011-10-31T20:45:02Z</EnableDate>
        <User>
          <UserId>AIDEXAMPLE4EXAMPLEXYZ</UserId>
          <Path>/</Path>
          <UserName>ExampleUser</UserName>
          <Arn>arn:aws:iam::111122223333:user/ExampleUser</Arn>
          <CreateDate>2011-07-01T17:23:07Z</CreateDate>
        </User>
      </member>
    </VirtualMFADevices>
  </ListVirtualMFADevicesResult>
  <ResponseMetadata>
    <RequestId>b61ce1b1-0401-11e1-b2f8-2dEXAMPLEbfc</RequestId>
  </ResponseMetadata>
</ListVirtualMFADevicesResponse>
</queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:ListVirtualMFADevicesRequestMsg" wsa:Action="urn:ListVirtualMFADevices"/>
      <wsdl:output message="tns:ListVirtualMFADevicesResponseMsg" wsa:Action="urn:ListVirtualMFADevices:Response"/>
    </wsdl:operation>

    <wsdl:operation name="DeleteRolePolicy">
      <wsdl:documentation><![CDATA[
    <p>Deletes the specified policy associated with the specified role.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=DeleteRolePolicy
&PolicyName=S3AccessPolicy
&RoleName=S3Access
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<DeleteRolePolicyResponse xmlns="https://iam.amazonaws.com/doc/2010-05-08/">
  <ResponseMetadata>
    <RequestId>c749ee7f-99ef-11e1-a4c3-27EXAMPLE804</RequestId>
  </ResponseMetadata>
</DeleteRolePolicyResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:DeleteRolePolicyRequestMsg" wsa:Action="urn:DeleteRolePolicy"/>
      <wsdl:output message="tns:DeleteRolePolicyResponseMsg" wsa:Action="urn:DeleteRolePolicy:Response"/>
    </wsdl:operation>

    <wsdl:operation name="CreateInstanceProfile">
      <wsdl:documentation><![CDATA[
    <p>Creates a new instance profile.</p>

    <p>For information about the number of instance profiles you can create, 
    see <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?LimitationsOnEntities.html" target="_blank">Limitations on IAM Entities</a> in <i>Using AWS Identity and Access Management</i>.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=CreateInstanceProfile
&InstanceProfileName=Webserver
&Path=/application_abc/component_xyz/
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<CreateInstanceProfileResponse xmlns="https://iam.amazonaws.com/doc/2010-05-08/">
  <CreateInstanceProfileResult>
    <InstanceProfile>
      <InstanceProfileId>AIPAD5ARO2C5EXAMPLE3G</InstanceProfileId>
      <Roles/>
      <InstanceProfileName>Webserver</InstanceProfileName>
      <Path>/application_abc/component_xyz/</Path>
      <Arn>arn:aws:iam::123456789012:instance-profile/application_abc/component_xyz/Webserver</Arn>
      <CreateDate>2012-05-09T16:11:10.222Z</CreateDate>
    </InstanceProfile>
  </CreateInstanceProfileResult>
  <ResponseMetadata>
    <RequestId>974142ee-99f1-11e1-a4c3-27EXAMPLE804</RequestId>
  </ResponseMetadata>
</CreateInstanceProfileResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:CreateInstanceProfileRequestMsg" wsa:Action="urn:CreateInstanceProfile"/>
      <wsdl:output message="tns:CreateInstanceProfileResponseMsg" wsa:Action="urn:CreateInstanceProfile:Response"/>
    </wsdl:operation>

    <wsdl:operation name="ListGroupPolicies">
      <wsdl:documentation><![CDATA[
    <p>Lists the names of the policies associated with the specified group. If there are none,
    the action returns an empty list.</p>

    <p>You can paginate the results using the <code>MaxItems</code> and <code>Marker</code> parameters.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=ListGroupPolicies
&GroupName=Admins
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<ListGroupPoliciesResponse>
   <ListGroupPoliciesResult>
      <PolicyNames>
         <member>AdminRoot</member>
         <member>KeyPolicy</member>
      </PolicyNames>
      <IsTruncated>false</IsTruncated>
   </ListGroupPoliciesResult>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</ListGroupPoliciesResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:ListGroupPoliciesRequestMsg" wsa:Action="urn:ListGroupPolicies"/>
      <wsdl:output message="tns:ListGroupPoliciesResponseMsg" wsa:Action="urn:ListGroupPolicies:Response"/>
    </wsdl:operation>

    <wsdl:operation name="CreateLoginProfile">
      <wsdl:documentation><![CDATA[
    <p>Creates a password for the specified user, giving the user the ability to access AWS services
       through the AWS Management Console.  For more information about managing passwords, see <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?Using_ManagingLogins.html" target="_blank">Managing Passwords</a> in <i>Using IAM</i>.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=CreateLoginProfile
&UserName=Bob
&Password=Password1
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<CreateLoginProfileResponse>
   <CreateUserResult>
      <LoginProfile>
         <UserName>Bob</UserName>
         <CreateDate>2011-09-19T23:00:56Z</CreateDate>
      </LoginProfile>
   </CreateUserResult>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</CreateLoginProfileResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:CreateLoginProfileRequestMsg" wsa:Action="urn:CreateLoginProfile"/>
      <wsdl:output message="tns:CreateLoginProfileResponseMsg" wsa:Action="urn:CreateLoginProfile:Response"/>
    </wsdl:operation>

    <wsdl:operation name="RemoveRoleFromInstanceProfile">
      <wsdl:documentation><![CDATA[
    <p>Removes the specified role from the specified instance profile.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=RemoveRoleFromInstanceProfile
&InstanceProfileName=Webserver
&RoleName=S3Access
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<RemoveRoleFromInstanceProfileResponse xmlns="https://iam.amazonaws.com/doc/2010-05-08/">
  <ResponseMetadata>
    <RequestId>29f47818-99f5-11e1-a4c3-27EXAMPLE804</RequestId>
  </ResponseMetadata>
</RemoveRoleFromInstanceProfileResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:RemoveRoleFromInstanceProfileRequestMsg" wsa:Action="urn:RemoveRoleFromInstanceProfile"/>
      <wsdl:output message="tns:RemoveRoleFromInstanceProfileResponseMsg" wsa:Action="urn:RemoveRoleFromInstanceProfile:Response"/>
    </wsdl:operation>

    <wsdl:operation name="UpdateAccountPasswordPolicy">
      <wsdl:documentation><![CDATA[
    <p>Updates the password policy settings for the account. For more information about 
    	using a password policy, go to <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/Using_ManagingPasswordPolicies.html">Managing an IAM Password Policy</a>.</p>

   <examples>
      <queryrequest>
https://iam.amazonaws.com/
?Action=UpdateAccountPasswordPolicy
&MinimumPasswordLength=9
&RequireSymbols=true
&RequireNumbers=false
&RequireUppercaseCharacters=true
&RequireLowercaseCharacters=true
&AllowUsersToChangePassword=true
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<UpdateAccountPasswordPolicyResponse>
   <ResponseMetadata>
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
   </ResponseMetadata>
</UpdateAccountPasswordPolicyResponse>
</queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:UpdateAccountPasswordPolicyRequestMsg" wsa:Action="urn:UpdateAccountPasswordPolicy"/>
      <wsdl:output message="tns:UpdateAccountPasswordPolicyResponseMsg" wsa:Action="urn:UpdateAccountPasswordPolicy:Response"/>
    </wsdl:operation>

    <wsdl:operation name="UpdateAssumeRolePolicy">
      <wsdl:documentation><![CDATA[
    <p>Updates the policy governing how the given role can be assumed.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=UpdateAssumeRolePolicy
&PolicyDocument={"Version":"2008-10-17","Statement":[{"Effect":"Allow","Principal":{"Service":["ec2.amazonaws.com"]},"Action":["sts:AssumeRole"]}]}
&RoleName=S3Access
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<UpdateAssumeRolePolicyResponse xmlns="https://iam.amazonaws.com/doc/2010-05-08/">
  <ResponseMetadata>
    <RequestId>309c1671-99ed-11e1-a4c3-270EXAMPLE04</RequestId>
  </ResponseMetadata>
</UpdateAssumeRolePolicyResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:UpdateAssumeRolePolicyRequestMsg" wsa:Action="urn:UpdateAssumeRolePolicy"/>
      <wsdl:output message="tns:UpdateAssumeRolePolicyResponseMsg" wsa:Action="urn:UpdateAssumeRolePolicy:Response"/>
    </wsdl:operation>

    <wsdl:operation name="GetInstanceProfile">
      <wsdl:documentation><![CDATA[
    <p>Retrieves information about the specified instance profile, including the instance profile's
    path, GUID, ARN, and role.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=GetInstanceProfile
&InstanceProfileName=Webserver
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<GetInstanceProfileResponse xmlns="https://iam.amazonaws.com/doc/2010-05-08/">
  <GetInstanceProfileResult>
    <InstanceProfile>
      <InstanceProfileId>AIPAD5ARO2C5EXAMPLE3G</InstanceProfileId>
      <Roles>
        <member>
          <Path>/application_abc/component_xyz/</Path>
          <Arn>arn:aws:iam::123456789012:role/application_abc/component_xyz/S3Access</Arn>
          <RoleName>S3Access</RoleName>
          <AssumeRolePolicyDocument>{"Version":"2008-10-17","Statement":[{"Effect":"Allow","Principal":{"Service":["ec2.amazonaws.com"]},"Action":["sts:AssumeRole"]}]}</AssumeRolePolicyDocument>
          <CreateDate>2012-05-09T15:45:35Z</CreateDate>
          <RoleId>AROACVSVTSZFEXAMPLEYK</RoleId>
        </member>
      </Roles>
      <InstanceProfileName>Webserver</InstanceProfileName>
      <Path>/application_abc/component_xyz/</Path>
      <Arn>arn:aws:iam::123456789012:instance-profile/application_abc/component_xyz/Webserver</Arn>
      <CreateDate>2012-05-09T16:11:10Z</CreateDate>
    </InstanceProfile>
  </GetInstanceProfileResult>
  <ResponseMetadata>
    <RequestId>37289fda-99f2-11e1-a4c3-27EXAMPLE804</RequestId>
  </ResponseMetadata>
</GetInstanceProfileResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:GetInstanceProfileRequestMsg" wsa:Action="urn:GetInstanceProfile"/>
      <wsdl:output message="tns:GetInstanceProfileResponseMsg" wsa:Action="urn:GetInstanceProfile:Response"/>
    </wsdl:operation>

    <wsdl:operation name="ListRoles">
      <wsdl:documentation><![CDATA[
    <p>Lists the roles that have the specified path prefix. If there are none, the action returns an empty list.</p>

    <p>You can paginate the results using the <code>MaxItems</code> and <code>Marker</code> parameters.</p>

    <p>The returned policy is URL-encoded according to RFC 3986. For more information about
       RFC 3986, go to <a href="http://www.faqs.org/rfcs/rfc3986.html">http://www.faqs.org/rfcs/rfc3986.html</a>.</p>

    <examples>

      <queryrequest>
https://iam.amazonaws.com/
?Action=ListRoles
&MaxItems=100
&PathPrefix=/application_abc/
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<ListRolesResponse xmlns="https://iam.amazonaws.com/doc/2010-05-08/">
  <ListRolesResult>
    <IsTruncated>false</IsTruncated>
    <Roles>
      <member>
        <Path>/application_abc/component_xyz/</Path>
        <Arn>arn:aws:iam::123456789012:role/application_abc/component_xyz/S3Access</Arn>
        <RoleName>S3Access</RoleName>
        <AssumeRolePolicyDocument>{"Version":"2008-10-17","Statement":[{"Effect":"Allow","Principal":{"Service":["ec2.amazonaws.com"]},"Action":["sts:AssumeRole"]}]}</AssumeRolePolicyDocument>
        <CreateDate>2012-05-09T15:45:35Z</CreateDate>
        <RoleId>AROACVSVTSZYEXAMPLEYK</RoleId>
      </member>
      <member>
        <Path>/application_abc/component_xyz/</Path>
        <Arn>arn:aws:iam::123456789012:role/application_abc/component_xyz/SDBAccess</Arn>
        <RoleName>SDBAccess</RoleName>
        <AssumeRolePolicyDocument>{"Version":"2008-10-17","Statement":[{"Effect":"Allow","Principal":{"Service":["ec2.amazonaws.com"]},"Action":["sts:AssumeRole"]}]}</AssumeRolePolicyDocument>
        <CreateDate>2012-05-09T15:45:45Z</CreateDate>
        <RoleId>AROAC2ICXG32EXAMPLEWK</RoleId>
      </member>
    </Roles>
  </ListRolesResult>
  <ResponseMetadata>
    <RequestId>20f7279f-99ee-11e1-a4c3-27EXAMPLE804</RequestId>
  </ResponseMetadata>
</ListRolesResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:ListRolesRequestMsg" wsa:Action="urn:ListRoles"/>
      <wsdl:output message="tns:ListRolesResponseMsg" wsa:Action="urn:ListRoles:Response"/>
    </wsdl:operation>

    <wsdl:operation name="GetAccountSummary">
      <wsdl:documentation><![CDATA[
    <p>Retrieves account level information about account entity usage and IAM quotas.</p>
    <p>For information about limitations on IAM entities, see 
    <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/index.html?LimitationsOnEntities.html" target="_blank">Limitations on IAM Entities</a> in <i>Using AWS Identity and Access Management</i>.</p>
    <examples>
      <queryrequest>
https://iam.amazonaws.com/
?Action=GetAccountSummary
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<GetAccountSummaryResponse>
  <GetAccountSummaryResult>
    <SummaryMap>
      <entry>
        <key>Groups</key>
        <value>31</value>
      </entry>
      <entry>
        <key>GroupsQuota</key>
        <value>50</value>
      </entry>
      <entry>
        <key>UsersQuota</key>
        <value>150</value>
      </entry>
      <entry>
        <key>Users</key>
        <value>35</value>
      </entry>
      <entry>
        <key>GroupPolicySizeQuota</key>
        <value>10240</value>
      </entry>
      <entry>
        <key>AccessKeysPerUserQuota</key>
        <value>2</value>
      </entry>
      <entry>
        <key>GroupsPerUserQuota</key>
        <value>10</value>
      </entry>
      <entry>
        <key>UserPolicySizeQuota</key>
        <value>10240</value>
      </entry>
      <entry>
        <key>SigningCertificatesPerUserQuota</key>
        <value>2</value>
      </entry>
      <entry>
        <key>ServerCertificates</key>
        <value>0</value>
      </entry>
      <entry>
        <key>ServerCertificatesQuota</key>
        <value>10</value>
      </entry>
      <entry>
        <key>AccountMFAEnabled</key>
        <value>0</value>
      </entry>
      <entry>
        <key>MFADevicesInUse</key>
        <value>10</value>
      </entry>
      <entry>
        <key>MFADevices</key>
        <value>20</value>
      </entry>
    </SummaryMap>
  </GetAccountSummaryResult>
  <ResponseMetadata>
    <RequestId>f1e38443-f1ad-11df-b1ef-a9265EXAMPLE</RequestId>
  </ResponseMetadata>
</GetAccountSummaryResponse>
      </queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:GetAccountSummaryRequestMsg" wsa:Action="urn:GetAccountSummary"/>
      <wsdl:output message="tns:GetAccountSummaryResponseMsg" wsa:Action="urn:GetAccountSummary:Response"/>
    </wsdl:operation>

    <wsdl:operation name="GetAccountPasswordPolicy">
      <wsdl:documentation><![CDATA[
  	<p>Retrieves the password policy for the AWS account. For more information about 
  		using a password policy, go to <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/Using_ManagingPasswordPolicies.html">Managing an IAM Password Policy</a>.</p>

   <examples>
      <queryrequest>
https://iam.amazonaws.com/
?Action=GetAccountPasswordPolicy
&Version=2010-05-08
&AUTHPARAMS
      </queryrequest>

      <queryresponse>
<GetAccountPasswordPolicyResponse>
    <PasswordPolicy> 
        <MinimumPasswordLength>6</MinimumPasswordLength>, 
        <RequireUppercaseCharacters>false</RequireUppercaseCharacters>
        <RequireLowercaseCharacters>false</RequireLowercaseCharacters> 
        <RequireNumbers>false</RequireNumbers> 
        <RequireSymbols>false</RequireSymbols>
        <AllowUsersToChangePassword>true</AllowUsersToChangePassword>
    </PasswordPolicy>	
    <ResponseMetadata> 
      <RequestId>7a62c49f-347e-4fc4-9331-6e8eEXAMPLE</RequestId>
    </ResponseMetadata>
</GetAccountPasswordPolicyResponse>	
</queryresponse>
    </examples>
  ]]></wsdl:documentation>
      <wsdl:input message="tns:GetAccountPasswordPolicyRequestMsg" wsa:Action="urn:GetAccountPasswordPolicy"/>
      <wsdl:output message="tns:GetAccountPasswordPolicyResponseMsg" wsa:Action="urn:GetAccountPasswordPolicy:Response"/>
    </wsdl:operation>

  </wsdl:portType>

  <wsdl:binding name="AWSIdentityManagementV20100508Binding" type="tns:AWSIdentityManagementV20100508PortType">

    <soap:binding style="document" transport="http://schemas.xmlsoap.org/soap/http"/>

    <wsdl:operation name="DeleteAccountAlias">
      <soap:operation soapAction="DeleteAccountAlias"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="ListGroups">
      <soap:operation soapAction="ListGroups"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="DeleteAccessKey">
      <soap:operation soapAction="DeleteAccessKey"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="DeleteVirtualMFADevice">
      <soap:operation soapAction="DeleteVirtualMFADevice"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="DeleteUserPolicy">
      <soap:operation soapAction="DeleteUserPolicy"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="PutUserPolicy">
      <soap:operation soapAction="PutUserPolicy"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="ListServerCertificates">
      <soap:operation soapAction="ListServerCertificates"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="GetUserPolicy">
      <soap:operation soapAction="GetUserPolicy"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="UpdateServerCertificate">
      <soap:operation soapAction="UpdateServerCertificate"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="UpdateUser">
      <soap:operation soapAction="UpdateUser"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="PutRolePolicy">
      <soap:operation soapAction="PutRolePolicy"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="UpdateSigningCertificate">
      <soap:operation soapAction="UpdateSigningCertificate"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="DeleteGroupPolicy">
      <soap:operation soapAction="DeleteGroupPolicy"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="ListUsers">
      <soap:operation soapAction="ListUsers"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="UpdateGroup">
      <soap:operation soapAction="UpdateGroup"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="CreateUser">
      <soap:operation soapAction="CreateUser"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="EnableMFADevice">
      <soap:operation soapAction="EnableMFADevice"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="DeleteAccountPasswordPolicy">
      <soap:operation soapAction="DeleteAccountPasswordPolicy"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="GetLoginProfile">
      <soap:operation soapAction="GetLoginProfile"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="UploadServerCertificate">
      <soap:operation soapAction="UploadServerCertificate"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="CreateGroup">
      <soap:operation soapAction="CreateGroup"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="CreateAccountAlias">
      <soap:operation soapAction="CreateAccountAlias"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="DeleteUser">
      <soap:operation soapAction="DeleteUser"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="DeactivateMFADevice">
      <soap:operation soapAction="DeactivateMFADevice"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="RemoveUserFromGroup">
      <soap:operation soapAction="RemoveUserFromGroup"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="DeleteRole">
      <soap:operation soapAction="DeleteRole"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="DeleteServerCertificate">
      <soap:operation soapAction="DeleteServerCertificate"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="CreateAccessKey">
      <soap:operation soapAction="CreateAccessKey"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="GetUser">
      <soap:operation soapAction="GetUser"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="ResyncMFADevice">
      <soap:operation soapAction="ResyncMFADevice"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="ListMFADevices">
      <soap:operation soapAction="ListMFADevices"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="CreateVirtualMFADevice">
      <soap:operation soapAction="CreateVirtualMFADevice"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="ListInstanceProfiles">
      <soap:operation soapAction="ListInstanceProfiles"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="UpdateAccessKey">
      <soap:operation soapAction="UpdateAccessKey"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="AddUserToGroup">
      <soap:operation soapAction="AddUserToGroup"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="GetGroup">
      <soap:operation soapAction="GetGroup"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="ListAccountAliases">
      <soap:operation soapAction="ListAccountAliases"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="DeleteGroup">
      <soap:operation soapAction="DeleteGroup"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="GetRole">
      <soap:operation soapAction="GetRole"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="ListRolePolicies">
      <soap:operation soapAction="ListRolePolicies"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="ListSigningCertificates">
      <soap:operation soapAction="ListSigningCertificates"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="UploadSigningCertificate">
      <soap:operation soapAction="UploadSigningCertificate"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="DeleteInstanceProfile">
      <soap:operation soapAction="DeleteInstanceProfile"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="CreateRole">
      <soap:operation soapAction="CreateRole"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="UpdateLoginProfile">
      <soap:operation soapAction="UpdateLoginProfile"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="DeleteLoginProfile">
      <soap:operation soapAction="DeleteLoginProfile"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="ChangePassword">
      <soap:operation soapAction="ChangePassword"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="GetServerCertificate">
      <soap:operation soapAction="GetServerCertificate"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="PutGroupPolicy">
      <soap:operation soapAction="PutGroupPolicy"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="DeleteSigningCertificate">
      <soap:operation soapAction="DeleteSigningCertificate"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="ListUserPolicies">
      <soap:operation soapAction="ListUserPolicies"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="ListAccessKeys">
      <soap:operation soapAction="ListAccessKeys"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="ListGroupsForUser">
      <soap:operation soapAction="ListGroupsForUser"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="AddRoleToInstanceProfile">
      <soap:operation soapAction="AddRoleToInstanceProfile"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="GetGroupPolicy">
      <soap:operation soapAction="GetGroupPolicy"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="GetRolePolicy">
      <soap:operation soapAction="GetRolePolicy"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="ListInstanceProfilesForRole">
      <soap:operation soapAction="ListInstanceProfilesForRole"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="ListVirtualMFADevices">
      <soap:operation soapAction="ListVirtualMFADevices"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="DeleteRolePolicy">
      <soap:operation soapAction="DeleteRolePolicy"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="CreateInstanceProfile">
      <soap:operation soapAction="CreateInstanceProfile"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="ListGroupPolicies">
      <soap:operation soapAction="ListGroupPolicies"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="CreateLoginProfile">
      <soap:operation soapAction="CreateLoginProfile"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="RemoveRoleFromInstanceProfile">
      <soap:operation soapAction="RemoveRoleFromInstanceProfile"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="UpdateAccountPasswordPolicy">
      <soap:operation soapAction="UpdateAccountPasswordPolicy"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="UpdateAssumeRolePolicy">
      <soap:operation soapAction="UpdateAssumeRolePolicy"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="GetInstanceProfile">
      <soap:operation soapAction="GetInstanceProfile"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="ListRoles">
      <soap:operation soapAction="ListRoles"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="GetAccountSummary">
      <soap:operation soapAction="GetAccountSummary"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

    <wsdl:operation name="GetAccountPasswordPolicy">
      <soap:operation soapAction="GetAccountPasswordPolicy"/>
      <wsdl:input><soap:body use="literal"/></wsdl:input>
      <wsdl:output><soap:body use="literal"/></wsdl:output>
    </wsdl:operation>

  </wsdl:binding>

  <wsdl:service name="AWSIdentityManagementV20100508">
    <wsdl:documentation><![CDATA[
    <fullname>AWS Identity and Access Management</fullname>

    <p>This guide provides descriptions of the Identity and Access Management (IAM) API 
      as well as links to related content in the guide, <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/" target="_blank">Using IAM</a>.</p>

    <p>IAM is a web service that enables AWS customers to manage users and user permissions under their AWS account.
      For more information about this product go to <a href="http://aws.amazon.com/iam/" target="_blank">AWS Identity and Access Management (IAM)</a>. For information about setting up signatures and 
    	authorization through the API, go to <a href="http://docs.amazonwebservices.com/general/latest/gr/signing_aws_api_requests.html" target="_blank">Signing AWS API Requests</a> in the <i>AWS General Reference</i>. For general information about 
    	using the Query API with IAM, go to <a href="http://docs.amazonwebservices.com/IAM/latest/UserGuide/IAM_UsingQueryAPI.html" target="_blank">Making Query Requests</a> in <i>Using IAM</i>.</p>
      
       <p>If you're new to AWS and need additional technical information about a specific AWS product, you can find the product's
technical documentation at <a href="http://aws.amazon.com/documentation/" target="_blank">http://aws.amazon.com/documentation/</a>.</p>
		
 ]]></wsdl:documentation>
    <wsdl:port name="AWSIdentityManagementV20100508Port" binding="tns:AWSIdentityManagementV20100508Binding">
      <soap:address location="https://iam.amazonaws.com"/>
    </wsdl:port>
  </wsdl:service>

</wsdl:definitions>